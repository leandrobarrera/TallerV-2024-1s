/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * autor 			: Leandro Barrera Salas
 ******************************************************************************
 */
#include <stdint.h>
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"

//Handlers GPIO, para los pines. Lo de toda la vida.
GPIO_Handler_t userLed = {0}; //	PinA5
GPIO_Handler_t LedA = {0}; //	PinC7
GPIO_Handler_t LedB = {0}; //	PinA9
GPIO_Handler_t LedC = {0}; //	PinCB6
GPIO_Handler_t LedD = {0}; //	PinC6
GPIO_Handler_t LedE = {0}; //	PinB9
GPIO_Handler_t LedF = {0}; //	PinA6
GPIO_Handler_t LedG = {0}; //	PinA0
GPIO_Handler_t switcheoD= {0};  // PinA7
GPIO_Handler_t switcheoI= {0};  // PinC9



// Definir variables
uint8_t contador = 0;
uint8_t unidades = 0;
uint8_t decenas = 0;

//Handlers para los tres timers que se pidieron
Timer_Handler_t contador_segundos = {0};
Timer_Handler_t blinkyTimer = {0};
Timer_Handler_t display = {0};

//Banderas. Se crearon banderas para la corecta ejecucicion y entendimiento de las interrupciones.
uint8_t display_flag = 0;
uint8_t display_select = 0;


/*
 * The main function, where EVERYTHING HAPPENS. The magic happens...
 */
// se creo una funcion para inicializar el sistema, esto ayuda a desplazarnos mas rapido en el codigo.
void init_system(void);

int main(void)
{
	init_system();



	while(1){
		if (contador == 60){
			contador = 0;
		}
		//almacenamos en las variables definidas anteriormente, una diferenciacion entre las unidades que nos genera el numero y las decenas del mismo, este numero es contador, que va sumando de a 1 seg.
		unidades = contador%10;
		decenas = contador/10;

		/* aqui decidimos usar WritePin "a la fuerza" es decir, sabemos que partes del 7segmentos se encienden
		 * para cada numero, entonces es solo plantear que leds encender para cada numero, haciendo esto, uno
		 * para las decenas y otro para las unidades. Tambien se pudo usar una variable auxiliar como se hizo
		 * en la tarea #1, pero con esto aunque algo tosco se muestre, ahorra codigo y es mas eficiente, ya que solo
		 * ponemos 1 o 0.
		 */

		/*NOTA IMPORTANTE: en esta parte del codigo se hizo algo muy importante, crear una bandera llamada display_flag
		 * y se activa cada 33ms con el soporte del Timer 3. Se usa esta bandera para el correcto entendimiento de las
		 * interrupciones. Este display flag empieza definida en 0 y cuando se cumple el primer ciclo dentro del micro
		 * el Timer3 la pone en 1, lo que hace que entre en este if que tenemos a continuacion.
		 *
		 * Con respecto al display_select es una variable igual de importante que display_flag, porque es la que habilita
		 * el switcheo correcto de los transistores, por tanto de que se pinten, apaguen y enciendan el display
		 * izquierdo y derecho es responsable esta variable. Usamos un XOR para poder hacer este switcheo, esta compuerta
		 * son dos ANDs que comparten una entrada y convergen en una compuerta logica OR. Lo clave de esto en este proceso
		 * es que con esta operacion cambiamos el valor logico de esta variable display_select los que nos permite entrar en
		 * la configuracion de las unidades o las decenas, y hagan sus respectivos procesos, sin sobreescribirse
		 * y evitando la generacion de fantasmas.
		 */

		if (display_flag){
			if(display_select){
				display_flag = 0;
				display_select^=1;
				gpio_WritePin(&switcheoI,1);
					if (unidades == 0){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 1);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 0);

					}
					else if (unidades == 1){
						gpio_WritePin(&LedA, 0);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 0);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 0);
						gpio_WritePin(&LedG, 0);
					}
					else if (unidades == 2){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 0);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 1);
						gpio_WritePin(&LedF, 0);
						gpio_WritePin(&LedG, 1);
					}
					else if (unidades == 3){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 0);
						gpio_WritePin(&LedG, 1);
					}
					else if (unidades == 4){
						gpio_WritePin(&LedA, 0);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 0);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					else if (unidades == 5){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 0);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					else if (unidades == 6){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 0);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 1);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					else if (unidades == 7){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 0);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 0);
						gpio_WritePin(&LedG, 0);
					}
					else if (unidades == 8){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 1);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					else {
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 0);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					gpio_WritePin(&switcheoD,0);
					//este GPIO aunque este puesto con 0 en su entrada logica, por ser un 7segmentos
					//con catodo comun en realidad prende la parte derecha del mismo y no apaga (lo que uno esperaria por ser 0 esta entrada logica) y vicerversa.

					//despues de cumplir con todas sus funciones, lo ponemos en 0.
				}
			else {
				//cuando display_select sea 0, entra aqui

					display_flag = 0;
					display_select^=1;
					gpio_WritePin(&switcheoD,1);

					if (decenas == 0){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 1);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 0);

					}
					else if (decenas == 1){
						gpio_WritePin(&LedA, 0);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 0);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 0);
						gpio_WritePin(&LedG, 0);
					}
					else if (decenas == 2){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 0);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 1);
						gpio_WritePin(&LedF, 0);
						gpio_WritePin(&LedG, 1);
					}
					else if (decenas == 3){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 0);
						gpio_WritePin(&LedG, 1);
					}
					else if (decenas == 4){
						gpio_WritePin(&LedA, 0);
						gpio_WritePin(&LedB, 1);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 0);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					else if (decenas == 5){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 0);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 0);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					else if (decenas == 6){
						gpio_WritePin(&LedA, 1);
						gpio_WritePin(&LedB, 0);
						gpio_WritePin(&LedC, 1);
						gpio_WritePin(&LedD, 1);
						gpio_WritePin(&LedE, 1);
						gpio_WritePin(&LedF, 1);
						gpio_WritePin(&LedG, 1);
					}
					gpio_WritePin(&switcheoI,0);
				}

			}



		}
	}


void init_system(void){
	/*	Configuramos el pin*/
	userLed.pGPIOx 							= 	GPIOA;
	userLed.pinConfig.GPIO_PinNumber		=	PIN_5;
	userLed.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);



	/*configuramos los pines, y cargamos las configuraciones asi como aprendimos en la tarea #1, nada nuevo. Aqui
	 * los "leds" son las divisiones que tiene el 7segmentos (a,b,c,d....), entonces los pines van a estas divisiones
	 * y encienden estos "leds" enumerados alfabeticamente. El 7segmentos tambien puede verse como un pin muy grande con
	 * varias conexiones.
	 */

	/*	LedA	*/
	LedA.pGPIOx 							= 	GPIOC;
	LedA.pinConfig.GPIO_PinNumber		=	PIN_7;
	LedA.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedA.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedA.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedA.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedA);


	/*	LedB	*/
	LedB.pGPIOx 							= 	GPIOA;
	LedB.pinConfig.GPIO_PinNumber		=	PIN_9;
	LedB.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedB.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedB.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedB.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedB);

	/*	LedC*/
	LedC.pGPIOx 							= 	GPIOB;
	LedC.pinConfig.GPIO_PinNumber		=	PIN_6;
	LedC.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedC.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedC.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedC.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedC);

	/*	LedD*/
	LedD.pGPIOx 							= 	GPIOC;
	LedD.pinConfig.GPIO_PinNumber		=	PIN_6;
	LedD.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedD.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedD.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedD.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedD);

	/*	LedE*/
	LedE.pGPIOx 							= 	GPIOB;
	LedE.pinConfig.GPIO_PinNumber		=	PIN_9;
	LedE.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedE.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedE.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedE.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedE);

	/*	LedF*/
	LedF.pGPIOx 							= 	GPIOA;
	LedF.pinConfig.GPIO_PinNumber		=	PIN_6;
	LedF.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedF.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedF.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedF.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedF);

	/*	LedG*/
	LedG.pGPIOx 							= 	GPIOB;
	LedG.pinConfig.GPIO_PinNumber		=	PIN_8;
	LedG.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedG.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedG.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_FAST;
	LedG.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedG);

	//la variable switcheo se convirtio en switcheoD (derecho) y switcheoI (izquierdo), ya que cambiamos la configuracion de los transistores, ya no estan mas en base comun.

	/*	switcheoD */
	switcheoD.pGPIOx 							= 	GPIOA;
	switcheoD.pinConfig.GPIO_PinNumber		=	PIN_7;
	switcheoD.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	switcheoD.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	switcheoD.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_FAST;
	switcheoD.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&switcheoD);

	/*	switcheoI */
	switcheoI.pGPIOx 							= 	GPIOC;
	switcheoI.pinConfig.GPIO_PinNumber		=	PIN_9;
	switcheoI.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	switcheoI.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	switcheoI.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_FAST;
	switcheoI.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&switcheoI);


	/*esto es lo nuevo, esta forma de cargar las configuraciones de los Handlers de los timers es parecida a
	 * los del GPIO, la primera fila para definir el que queremos usar (quedan a eleccion del programador) no obstante
	 * en la tarea se nos pide que usemos ciertos timers con cierto numero especifico de bits, 32 para unos y 16 para otros.
	 * Por tanto se uso esta escogencia. En la segunda fila del prescaler se usa el 16000 para que durante todo este
	 * proceso de interrupciones, y teniendo que el micro va a 16MHz, el 16000 divide esta cifra y la deja en un formato de
	 * 1 ms. Este 1 ms se multiplica por el periodo, y lo elegimos segun lo que requiramos. Para el TIM2 pusimos 1000
	 * que 1ms * 1000, nos da 1000ms lo que es igual a 1 segundo, lo que completa nuestro deseo que este contador de segundos
	 * en efecto, cuente segundos. Para el blinky de manera "estandar" hacemos que vaya a un ratio de 250 ms.
	 */

	contador_segundos.pTIMx 							= TIM2;
	contador_segundos.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	contador_segundos.TIMx_Config.TIMx_Period			=1000;  //	se pone 1000 porque en combinacion con el prescaler que es 16000, esa division da para que el timer vaya a 1000ms
	contador_segundos.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	contador_segundos.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&contador_segundos);

	//	Encedemos el Timer.
	timer_SetState(&contador_segundos,SET);

	blinkyTimer.pTIMx 							= TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period			=250;  //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer,SET);

	display.pTIMx 							= TIM3;
	display.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	display.TIMx_Config.TIMx_Period			=8;  //	60FPS ultra calidad gamer. Se tuvo que subir porque no se veía fluido el refresco, antes era 15, que significaban 60 FPS
	display.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	display.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&display);

	//	Encedemos el Timer.
	timer_SetState(&display,SET);




}



/*
 *  Overwrite function
 **/




/* en este callback se sube y baja la bandera (UIF) permitiendo que se de la interrupcion y no quede
 * interrumpido indefinidamente, al mismo tiempo siendo este el timer que usamos para nuestro contador de segundos
 * hacemos que durante esta interrupcion (de 1 seg, valga la redundancia) se nos sume a una variable auxiliar que llamamos
 * contador, que es la que nos ayuda en la parte del codigo del display, para ir mostrando los numeros en el momento que
 * necesitamos. Es decir cuando se hace la interrupcion, esta misma (administrada por el timer2) suma +1 al contador.
 * Esta parte del codigo ademas de mandar la interrupcion, tambien detiene la misma.
 */

void Timer2_Callback(void){

	contador ++;
}



void Timer3_Callback(void){
	display_flag = 1;
}

/* este el callback del Led de estado, usamos el TooglePin para que se enciende y se apague, es la unico para lo
 * que nos sirve esta interrupcion. A grandes rasgos sirve para saber que el sistema funciona.
 */
void Timer5_Callback(void){
	gpio_TooglePin(&userLed);
}





/*
 *  Esta funcion sirve para detectar problemas de parametros
 *  incorrectos al momento de ejecutar un programa.
   */
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		//problems...
	}
}
