/**
 **************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * autor 		   : lbarreras
 * fecha 		   : 17/09/2024
 **************************
 */

/* ============== GUITAR HERO LEGENDS OF ROCK-8BIT ============== */

#include <stdint.h>
#include <math.h>
#include <stdbool.h>
#include <string.h>
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "usart_driver_hal.h"
#include "i2c_driver_hal.h"
#include "pwm_driver_hal.h"
#include "exti_driver_hal.h"
#include "systick_driver_hal.h"
#include "oled_driver.h"

//Handlers

Timer_Handler_t blinkyTimer = { 0 };
GPIO_Handler_t userLed = { 0 }; 	//	PinA5
GPIO_Handler_t botonDerecho = { 0 }; 		//	PinC8
GPIO_Handler_t botonCentro = { 0 }; 		//	PinB8
GPIO_Handler_t botonIzquierdo = { 0 }; 		//	PinB8
GPIO_Handler_t gpio_buzzer = { 0 }; 		//
EXTI_Config_t exti_botonDerecho = { 0 };		//	Pin
EXTI_Config_t exti_botonCentro = { 0 };		//	Pin
EXTI_Config_t exti_botonIzquierdo = { 0 };		//	Pin
PWM_Handler_t pwm_buzzer = { 0 };	// PinB2

/* Elementos para la comunicacion serial  llevar nuevo */
uint8_t usart2DataReceived = 0;
char bufferMsg[64] = { 0 };
USART_Handler_t commSerial = { 0 };
GPIO_Handler_t pinTx = { 0 };
GPIO_Handler_t pinRx = { 0 };


//variables
uint8_t flag_updateAccel = 0; //bandera para la actualizacion de los datos entregados por el Acelerometro
int16_t var_Accel = 0; // variable global del acel. para la funcion que se uso de parametrizar

//Variables

//flags
uint8_t flag_botonDerecho;
uint8_t flag_botonCentro;
uint8_t flag_botonIzquierdo;

//buzzer
// change this to make the song slower or faster
uint8_t tempo = 0;

// change this to whichever pin you want to use
uint8_t buzzer = 0;

//variables botones
uint8_t readDerecho = 0;
uint8_t readCentro = 0;
uint8_t readIzquierdo = 0;

//Notas musicales
#define NOTE_B0  31
#define NOTE_C1  33
#define NOTE_CS1 35
#define NOTE_D1  37
#define NOTE_DS1 39
#define NOTE_E1  41
#define NOTE_F1  44
#define NOTE_FS1 46
#define NOTE_G1  49
#define NOTE_GS1 52
#define NOTE_A1  55
#define NOTE_AS1 58
#define NOTE_B1  62
#define NOTE_C2  65
#define NOTE_CS2 69
#define NOTE_D2  73
#define NOTE_DS2 78
#define NOTE_E2  82
#define NOTE_F2  87
#define NOTE_FS2 93
#define NOTE_G2  98
#define NOTE_GS2 104
#define NOTE_A2  110
#define NOTE_AS2 117
#define NOTE_B2  123
#define NOTE_C3  131
#define NOTE_CS3 139
#define NOTE_D3  147
#define NOTE_DS3 156
#define NOTE_E3  165
#define NOTE_F3  175
#define NOTE_FS3 185
#define NOTE_G3  196
#define NOTE_GS3 208
#define NOTE_A3  220
#define NOTE_AS3 233
#define NOTE_B3  247
#define NOTE_C4  262
#define NOTE_CS4 277
#define NOTE_D4  294
#define NOTE_DS4 311
#define NOTE_E4  330
#define NOTE_F4  349
#define NOTE_FS4 370
#define NOTE_G4  392
#define NOTE_GS4 415
#define NOTE_A4  440
#define NOTE_AS4 466
#define NOTE_B4  494
#define NOTE_C5  523
#define NOTE_CS5 554
#define NOTE_D5  587
#define NOTE_DS5 622
#define NOTE_E5  659
#define NOTE_F5  698
#define NOTE_FS5 740
#define NOTE_G5  784
#define NOTE_GS5 831
#define NOTE_A5  880
#define NOTE_AS5 932
#define NOTE_B5  988
#define NOTE_C6  1047
#define NOTE_CS6 1109
#define NOTE_D6  1175
#define NOTE_DS6 1245
#define NOTE_E6  1319
#define NOTE_F6  1397
#define NOTE_FS6 1480
#define NOTE_G6  1568
#define NOTE_GS6 1661
#define NOTE_A6  1760
#define NOTE_AS6 1865
#define NOTE_B6  1976
#define NOTE_C7  2093
#define NOTE_CS7 2217
#define NOTE_D7  2349
#define NOTE_DS7 2489
#define NOTE_E7  2637
#define NOTE_F7  2794
#define NOTE_FS7 2960
#define NOTE_G7  3136
#define NOTE_GS7 3322
#define NOTE_A7  3520
#define NOTE_AS7 3729
#define NOTE_B7  3951
#define NOTE_C8  4186
#define NOTE_CS8 4435
#define NOTE_D8  4699
#define NOTE_DS8 4978
#define REST 1

void tone(PWM_Handler_t *ptrPwmHandler, uint16_t newFreq, uint16_t duration);
void noTone(PWM_Handler_t *ptrPwmHandler);
void init_system(void);
void songPlay(void);

int main(void) {
	init_system();

	while (1) {

		readDerecho = gpio_ReadPin(&botonDerecho);

		readIzquierdo = gpio_ReadPin(&botonIzquierdo);

		readCentro = gpio_ReadPin(&botonCentro);

		if(readDerecho == 0){
			songPlay();
		}



		}


	}



void songPlay(void){
	// change this to make the song slower or faster
		tempo = 108;

		// change this to whichever pin you want to use
		buzzer = 11;

		// notes of the melody followed by the duration.
		// a 4 means a quarter note, 8 an eighteenth , 16 sixteenth, so on
		// !!negative numbers are used to represent dotted notes,
		// so -4 means a dotted quarter note, that is, a quarter plus an eighteenth!!

		//Arreglar loop infinito
		int melody[256] = {

		NOTE_AS4, 8, NOTE_AS4, 8, NOTE_AS4,
				8, //1
				NOTE_F5, 2, NOTE_C6, 2,
				NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8, NOTE_F6, 2, NOTE_C6, 4,
				NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8, NOTE_F6, 2, NOTE_C6, 4,
				NOTE_AS5, 8, NOTE_A5, 8, NOTE_AS5, 8, NOTE_G5, 2, NOTE_C5, 8,
				NOTE_C5, 8, NOTE_C5, 8,
				NOTE_F5, 2, NOTE_C6, 2,
				NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8, NOTE_F6, 2, NOTE_C6, 4,

				NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8, NOTE_F6, 2, NOTE_C6,
				4, //8
				NOTE_AS5, 8, NOTE_A5, 8, NOTE_AS5, 8, NOTE_G5, 2, NOTE_C5, -8,
				NOTE_C5, 16,
				NOTE_D5, -4, NOTE_D5, 8, NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8,
				NOTE_F5, 8,
				NOTE_F5, 8, NOTE_G5, 8, NOTE_A5, 8, NOTE_G5, 4, NOTE_D5, 8, NOTE_E5,
				4, NOTE_C5, -8, NOTE_C5, 16,
				NOTE_D5, -4, NOTE_D5, 8, NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8,
				NOTE_F5, 8,

				NOTE_C6, -8, NOTE_G5, 16, NOTE_G5, 2, REST, 8, NOTE_C5,
				8, //13
				NOTE_D5, -4, NOTE_D5, 8, NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8,
				NOTE_F5, 8,
				NOTE_F5, 8, NOTE_G5, 8, NOTE_A5, 8, NOTE_G5, 4, NOTE_D5, 8, NOTE_E5,
				4, NOTE_C6, -8, NOTE_C6, 16,
				NOTE_F6, 4, NOTE_DS6, 8, NOTE_CS6, 4, NOTE_C6, 8, NOTE_AS5, 4,
				NOTE_GS5, 8, NOTE_G5, 4, NOTE_F5, 8,
				NOTE_C6, 1

		};



		// this calculates the duration of a whole note in ms
		int16_t wholenote = (60000 * 4) / tempo;

		int16_t divider = 0;
		int16_t noteDuration = 0;

	//	 iterate over the notes of the melody.
	//	 Remember, the array is twice the number of notes (notes + durations)
		for (int16_t thisNote = 0; thisNote < 173; thisNote = thisNote + 2) {

			// calculates the duration of each note
			divider = melody[thisNote + 1];
			if (divider > 0) {
				// regular note, just proceed
				noteDuration = (wholenote) / divider;
			} else if (divider < 0) {
				// dotted notes are represented with negative durations!!
	//			noteDuration = (wholenote) / abs(divider);
				noteDuration = (wholenote) / divider;
				noteDuration *= -1.5; // increases the duration in half for dotted notes
			}

			// we only play the note for 90% of the duration, leaving 10% as a pause
			tone(&pwm_buzzer, melody[thisNote], noteDuration * 0.9);

			// Wait for the specief duration before playing the next note.
			systick_Delay_ms(noteDuration);

			// stop the waveform generation before the next note.
			noTone(&pwm_buzzer);
		}
}
void init_system(void) {

	/*	Configuramos los pines*/

	/* userLed */
	userLed.pGPIOx = GPIOA;
	userLed.pinConfig.GPIO_PinNumber = PIN_5;
	userLed.pinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType = GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);



	/*	botonDerecho	*/
	botonDerecho.pGPIOx = GPIOC;
	botonDerecho.pinConfig.GPIO_PinNumber = PIN_13;
	botonDerecho.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonDerecho);

	/*	botonCentro	*/
	botonCentro.pGPIOx = GPIOC;
	botonCentro.pinConfig.GPIO_PinNumber = PIN_6;
	botonCentro.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonCentro);

	/*	botonIzquierdo*/
	botonIzquierdo.pGPIOx = GPIOC;
	botonIzquierdo.pinConfig.GPIO_PinNumber = PIN_5;
	botonIzquierdo.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonIzquierdo);


	//Timer del Blinky
	blinkyTimer.pTIMx = TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler = 16000; //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period = 250; //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode = TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable = TIMER_INT_ENABLE;  //

	/*	Configuramos el Timer */
	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer, SET);

	pwm_buzzer.ptrTIMx = TIM2;
	pwm_buzzer.config.channel = PWM_CHANNEL_2;
	pwm_buzzer.config.periodo = 200;
	pwm_buzzer.config.prescaler = 3; // freq
	pwm_buzzer.config.duttyCicle = 1; /* Se define el ciclo de trabajo (dutty cycle) del PWM en 100 (50%) */

	/* Se carga el PWM con los parametros establecidos */
	pwm_Config(&pwm_buzzer);

	/* Buzzer */
	gpio_buzzer.pGPIOx = GPIOB;
	gpio_buzzer.pinConfig.GPIO_PinNumber = PIN_3;
	gpio_buzzer.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	gpio_buzzer.pinConfig.GPIO_PinOutputType = GPIO_OTYPE_PUSHPULL;
	gpio_buzzer.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	gpio_buzzer.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	gpio_buzzer.pinConfig.GPIO_PinAltFunMode = AF1;

	gpio_Config(&gpio_buzzer);


	config_SysTick_ms(0);



}

void tone(PWM_Handler_t *ptrPwmHandler, uint16_t newFreq, uint16_t duration) {

	uint16_t newPeriod = 0;
	newPeriod = 5333333 / newFreq;

	pwm_Update_Frequency(ptrPwmHandler, newPeriod);
	pwm_Update_DuttyCycle(ptrPwmHandler, duration);
	pwm_Start_Signal(ptrPwmHandler);

}
void noTone(PWM_Handler_t *ptrPwmHandler) {
	pwm_Stop_Signal(ptrPwmHandler);
}


//Callbacks del EXTI.

//void callback_ExtInt8(void) {
//
//	flag_botonDerecho = gpio_ReadPin(&botonDerecho);
//
//}
//
//void callback_ExtInt6(void) {
//
//	flag_botonCentro += 1;
//}
//
//void callback_ExtInt5(void) {
//
//	flag_botonIzquierdo += 1;
//}

//Callbacks de los timers

/* este el callback del Led de estado, usamos el TooglePin para que se enciende y se apague, es la unico para lo
 * que nos sirve esta interrupcion. A grandes rasgos sirve para saber que el sistema funciona.

 Ademas de eso, agregamos la bandera para que se de la conversion de adc y la inicializacion de la variable sendMsg*/
void Timer5_Callback(void) {
	gpio_TooglePin(&userLed);

}

/* Callback usart2 */
void usart2_RxCallback(void) {
	usart2DataReceived = usart_getRxData();
}

/*
 *Esta funcion sirve para detectar problemas de parametros
 *incorrectos
 **/
void assert_failed(uint8_t *file, uint32_t line) {
	while (1) {
		// problems
	}
}
