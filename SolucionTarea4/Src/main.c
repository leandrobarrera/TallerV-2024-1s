/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * autor 		   : lbarreras
 * fecha 		   : 17/09/2024
 ******************************************************************************
 */
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "usart_driver_hal.h"
#include "i2c_driver_hal.h"
#include "pwm_driver_hal.h"


//RECORDAR QUE NO HAY BOTON DE RESET. SE SACO APARTE.

// Definicion de los handlers necesario
GPIO_Handler_t userLed = {0};

GPIO_Handler_t LedRed = {0};
GPIO_Handler_t LedGreen = {0};
GPIO_Handler_t LedBlue = {0};

// Comunicacion R232 con el PC, ya habilitada en el board ucleo
// Utiliza la conexion USB
USART_Handler_t commserial = {0};

GPIO_Handler_t pinTx = {0};
GPIO_Handler_t pinRx = {0};

/* Timers */
Timer_Handler_t blinkyTimer = {0};
Timer_Handler_t updateAccel= {0};


/* Pines para el I2C */
GPIO_Handler_t pinSCL = {0};
GPIO_Handler_t pinSDA = {0};
I2C_Handler_t accelSensor = {0};
uint8_t i2c_AuxBuffer = {0};


//variables
uint8_t flag_updateAccel = 0; //bandera para la actualizacion de los datos entregados por el Acelerometro
int16_t var_Accel = 0; // variable global del acel. para la funcion que se uso de parametrizar

//Handlers para los tres timers que se pidieron
PWM_Handler_t red_pwm = {0};
PWM_Handler_t blue_pwm = {0};
PWM_Handler_t green_pwm = {0};



/* registros y valores relacionados con el MPU */
#define ACCEL_ADDRESS	0b1101001;	// 0xD1 -> Direccion del Accel con Logic_0 (buscado en internet)
#define ACCEL_XOUT_H	59	// 0x3B
#define ACCEL_XOUT_L	60	// 0x3C
#define ACCEL_YOUT_H	61	// 0x3D
#define ACCEL_YOUT_L	62	// 0x3E
#define ACCEL_ZOUT_H	63	// 0x3F
#define ACCEL_ZOUT_L	64	// 0x40
#define PWM_MGMT_1		107
#define WHO_AM_I		117

uint8_t receivedChar = '\0';
uint8_t sendMsg = 0;

// Mensaje que se imprimen
char greetingMsg[] = "Taller V Rocks!\n";
char bufferData[64] = "Accel MPU-6050 testing...\n";

// Definicion de las cabeceras de las funciones del main
void initSystem(void);
void config_LedRGB(void);
void config_I2C(void);
void param_rango(int16_t dataAccel); //funcion para parametrizar los datos recogidos del acel.

/**
 * Funcion principal del programa.
 * Esta funcion es el corazon del programa!!
 *
 * */
int main(void){

	// Inicializamos todos los elementos del sistema
	initSystem();

	config_LedRGB();

	config_I2C();

	usart_writeMsg(&commserial, greetingMsg);

	i2c_WriteSingleRegisters(&accelSensor, PWM_MGMT_1, 0x00); //se hace reseteo de los datos que se tengan.

	/* Loop forever */
	while(1){

		// El sistema siempre esta verificando si el valor de  rxData ha cambiado
		//	lo cual sucede en la ISR de la recepcion (RX).
		//	Si este valor deja de ser '\0' significa que se recibio un caracter
		//	por lo tanto entra en el bloque if para analizar que se recibio
		if(receivedChar != '\0'){
			if(receivedChar == 'm'){
				// Presentamos un mensaje
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';
			}

			if (receivedChar == 'w'){
			    /* Si el caracter recibido es 'w', se lee el registro WHO_AM_I del acelerometro */
				sprintf(bufferData, "WHO_AM_I? (r)\n"); // Prepara el mensaje que indica que se va a leer el registro WHO_AM_I
				usart_writeMsg(&commserial, bufferData); // Envia el mensaje por USART

				 /* Se lee el valor del registro WHO_AM_I del sensor a traves de I2C */
				i2c_AuxBuffer = i2c_ReadSingleRegister(&accelSensor, WHO_AM_I); // Realiza la lectura del registro WHO_AM_I a traves de I2C
				sprintf(bufferData, "dataRead = 0x%x \n", (unsigned int) i2c_AuxBuffer); // Formatea el dato leido en hexadecimal
				usart_writeMsg(&commserial, bufferData); // Envia el valor leido a trav√©s de USART
				receivedChar = '\0'; /* Se resetea receivedChar para esperar un nuevo caracter */
			}

			else if (receivedChar == 'p'){
				/* Si el caracter recibido es 'p', se lee el registro PWM_MGMT_1 del sensor */
				sprintf(bufferData, "PWM_MGMT_1_state (r)\n"); // Prepara el mensaje para indicar que se va a leer el estado del registro PWM_MGMT_1
				usart_writeMsg(&commserial, bufferData);// Envia el mensaje por USART

				/* Se lee el valor del registro PWM_MGMT_1 del sensor */
				i2c_AuxBuffer = i2c_ReadSingleRegister(&accelSensor, PWM_MGMT_1); // Lee el valor del registro PWM_MGMT_1
				sprintf(bufferData, "dataRead = 0x%x \n", (unsigned int) i2c_AuxBuffer); // Formatea el valor leido en hexadecimal
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';
			}

			else if (receivedChar == 'r'){
				sprintf(bufferData, "PWM_MGMT_1_reset (w)\n");
				usart_writeMsg(&commserial, bufferData);

				i2c_WriteSingleRegisters(&accelSensor, PWM_MGMT_1, 0x00);
				receivedChar = '\0';
			}

		    /* Si el caracter recibido es 'x', se leen los datos del eje X del acelerometro */
			else if(receivedChar == 'x'){

				sprintf(bufferData, "Axis x data  (r)\n "); // Prepara el mensaje indicando que se leeran los datos del eje X
				usart_writeMsg(&commserial, bufferData);

			    /* Se leen los registros bajo y alto del eje X y se combinan en un valor de 16 bits. Esto es porque tenemos una variable de 16 bits pero toca dividirla en dos de 8 bits, y luego shiftearla */
				uint8_t AccelLX_low  = i2c_ReadSingleRegister(&accelSensor, ACCEL_XOUT_L);
				uint8_t AccelLX_high = i2c_ReadSingleRegister(&accelSensor, ACCEL_XOUT_H);
				int16_t AccelX = AccelLX_high << 8 |  AccelLX_low; // se shiftea. Combina ambos bytes en un entero de 16 bits para obtener el valor total del eje X

			    /* Se imprime el valor del eje X */
				sprintf(bufferData, "Accelx = %d \n",  (int) AccelX); // El valor del eje X como decimal en el formato
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';

				}
			else if(receivedChar == 'y'){ /* Para Y es lo mismo */
				sprintf(bufferData, "Axis y data  (r)\n ");
				usart_writeMsg(&commserial, bufferData);

				uint8_t AccelLY_low  = i2c_ReadSingleRegister(&accelSensor, ACCEL_YOUT_L);
				uint8_t AccelLY_high = i2c_ReadSingleRegister(&accelSensor, ACCEL_YOUT_H);
				int16_t AccelY = AccelLY_high << 8 |  AccelLY_low;
				sprintf(bufferData, "AccelY = %d \n",  (int) AccelY);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';

				}
			else if(receivedChar == 'z'){ /* Para Z lo mismo */
				sprintf(bufferData, "Axis z data  (r)\n ");
				usart_writeMsg(&commserial, bufferData);

				uint8_t AccelLZ_low  = i2c_ReadSingleRegister(&accelSensor, ACCEL_ZOUT_L);
				uint8_t AccelLZ_high = i2c_ReadSingleRegister(&accelSensor, ACCEL_ZOUT_H);
				int16_t AccelZ = AccelLZ_high << 8 |  AccelLZ_low;
				sprintf(bufferData, "AccelZ = %d \n",  (int) AccelZ);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';

				}
			else if(receivedChar == 'q'){
				/* Si el caracter recibido es 'q', se leen los datos de los tres ejes del acelerometro */
				sprintf(bufferData, "All 3 axis  (r)\n "); // Prepara el mensaje indicando que se leeran los datos de los ejes X, Y y Z
				usart_writeMsg(&commserial, bufferData);

			    /* Se leen los registros de los tres ejes X, Y y Z y se almacenan en un arreglo */
				uint8_t AccelData[6] = {0}; // Arreglo de 6 bytes para almacenar los datos de los tres ejes (2 bytes por eje)
				i2c_ReadManyRegisters(&accelSensor, ACCEL_XOUT_H, AccelData, 6);

				 /* Se combinan los registros de alto y bajo para obtener valores de 16 bits de cada eje */
				int16_t AccelX = AccelData[0] << 8 | AccelData[1];
				int16_t AccelY = AccelData[2] << 8 | AccelData[3];
				int16_t AccelZ = AccelData[4] << 8 | AccelData[5];
				sprintf(bufferData, "Accel x,y,z -> %d  %d %d \n", (int) AccelX, (int) AccelY, (int) AccelZ);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';
				}

			receivedChar = '\0';
		}

		/* Si la bandera flag_updateAccel esta activa (es 1), se actualizan los datos del acelerometro periodicamente */
		if (flag_updateAccel){
		    /* Se inicializa un arreglo de 6 bytes para almacenar los datos de los tres ejes del acelerometro (X, Y, Z) */
			uint8_t AccelData[6] = {0};
			i2c_ReadManyRegisters(&accelSensor, ACCEL_XOUT_H, AccelData, 6);

		    /* Se combinan los bytes alto y bajo de cada eje para obtener los valores de 16 bits correspondientes a X, Y y Z */
			int16_t AccelX = AccelData[0] << 8 | AccelData[1];
			int16_t AccelY = AccelData[2] << 8 | AccelData[3];
			int16_t AccelZ = AccelData[4] << 8 | AccelData[5];
		    /* Se pone formato a los valores de los tres ejes para imprimirlos en un mensaje */
			sprintf(bufferData, "Accel x,y,z -> %d %d %d \n", (int) AccelX, (int) AccelY, (int) AccelZ);
			usart_writeMsg(&commserial, bufferData);
			receivedChar = '\0';

			/* Para esta funcion, se parametriza porque no podemos tomar valores mayores a 16438 aproximadamente, por tanto los que sean mayores no lo
			 * manda a los extremos respectivos, para el positivo a 16438 y para el negativo -16438. Es importante recordar que como dato maximo
			 * el acelerometro 6050 registra datos de -2g hasta 2g, es decir [-32876,32876]. El nuevo rango que usamos es [0,200].
			 */

		    /* Se ajusta el ciclo de trabajo (duty cycle) del PWM segun el valor del eje X */
			 param_rango(AccelX); // Se ajusta la variable var_Accel segun el rango de AccelX
			 pwm_Update_DuttyCycle(&red_pwm, var_Accel); // Se actualiza el PWM del color rojo

			 /* Se ajusta el ciclo de trabajo del PWM segun el valor del eje Y */
			 param_rango(AccelY); // Se ajusta la variable var_Accel segun el rango de AccelY
			 pwm_Update_DuttyCycle(&green_pwm, var_Accel); // Se actualiza el PWM del color verde

			 /* Se ajusta el ciclo de trabajo del PWM segun el valor del eje Z */
			 param_rango(AccelZ); // Se ajusta la variable var_Accel segun el rango de AccelZ
			 pwm_Update_DuttyCycle(&blue_pwm, var_Accel); // Se actualiza el PWM del color azul
			 flag_updateAccel = 0;
			}
		   }
    return 0;
}
	/* Funcion encargada de la inicializacion del sistema */

void initSystem(void)
{
	/*	Configuramos el pin*/
	userLed.pGPIOx 							= 	GPIOA;
	userLed.pinConfig.GPIO_PinNumber		=	PIN_5;
	userLed.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);
	gpio_WritePin(&userLed, 1);


	blinkyTimer.pTIMx 							= TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period			=250;  //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer,SET);

	// Configuramos el Timer (refresco 10 ms)
	updateAccel.pTIMx								= TIM2;
	updateAccel.TIMx_Config.TIMx_Prescaler			= 1600; //	genera incremento  de 1 ms
	updateAccel.TIMx_Config.TIMx_Period 				= 500; 	//	de la mano con el prescaler
	updateAccel.TIMx_Config.TIMx_mode 				=TIMER_UP_COUNTER;
	updateAccel.TIMx_Config.TIMx_InterruptEnable	 	=TIMER_INT_ENABLE;
	timer_Config(&updateAccel);

	/* Encendemos los timers */
	timer_SetState(&updateAccel, TIMER_ON);

	/* Configuramos los pines del puerto serial
	 * pin sobre el que funciona el USART2 (TX) */
	pinTx.pGPIOx                          = GPIOA;
	pinTx.pinConfig.GPIO_PinNumber        = PIN_2;
	pinTx.pinConfig.GPIO_PinMode          = GPIO_MODE_ALTFN;
	pinTx.pinConfig.GPIO_PinAltFunMode	  = AF7;
	pinTx.pinConfig.GPIO_PinOutputSpeed   = GPIO_OSPEED_FAST;
	pinTx.pinConfig.GPIO_PinPuPdControl   = GPIO_PUPDR_NOTHING;

	/* Escribimos la configuracion en la memoria del MCU */
	gpio_Config(&pinTx);

	/* Pin sobre el que funciona el USART2 (RX) */
	pinRx.pGPIOx                          = GPIOA;
	pinRx.pinConfig.GPIO_PinNumber        = PIN_3;
	pinRx.pinConfig.GPIO_PinMode          = GPIO_MODE_ALTFN;
	pinRx.pinConfig.GPIO_PinAltFunMode	  = AF7;
	pinRx.pinConfig.GPIO_PinOutputType    = GPIO_OTYPE_PUSHPULL;
	pinRx.pinConfig.GPIO_PinOutputSpeed   = GPIO_OSPEED_FAST;
	pinRx.pinConfig.GPIO_PinPuPdControl   = GPIO_PUPDR_NOTHING;

	/* Escribimos la configuracion en la memoria del MCU */
	gpio_Config(&pinRx);



	//Configuramos el puerto serial (USART2)
	commserial.ptrUSARTx				= USART2;
	commserial.USART_Config.baudrate    = USART_BAUDRATE_19200;
	commserial.USART_Config.datasize	= USART_DATASIZE_8BIT;
	commserial.USART_Config.parity		= USART_PARITY_EVEN;
	commserial.USART_Config.stopbits	= USART_STOPBIT_1;
	commserial.USART_Config.mode 		= USART_MODE_RXTX;
	commserial.USART_Config.enableIntRX = USART_RX_INTERRUP_ENABLE;

	/* Escribimos la configuracion en la memoria del MCU */
	usart_Config(&commserial);

	usart_WriteChar(&commserial, '\0');

}

/**/
void config_I2C(void)
{
	pinSCL.pGPIOx 								= GPIOB;
	pinSCL.pinConfig.GPIO_PinNumber        		= PIN_6;
	pinSCL.pinConfig.GPIO_PinMode          		= GPIO_MODE_ALTFN;
	pinSCL.pinConfig.GPIO_PinAltFunMode	  		= AF4;
	pinSCL.pinConfig.GPIO_PinOutputType   		= GPIO_OTYPE_OPENDRAIN;
	pinSCL.pinConfig.GPIO_PinOutputSpeed   	  	= GPIO_OSPEED_FAST;
	pinSCL.pinConfig.GPIO_PinPuPdControl  		= GPIO_PUPDR_NOTHING;
	gpio_Config(&pinSCL);

	pinSDA.pGPIOx 								= GPIOB;
	pinSDA.pinConfig.GPIO_PinNumber        		= PIN_9;
	pinSDA.pinConfig.GPIO_PinMode          		= GPIO_MODE_ALTFN;
	pinSDA.pinConfig.GPIO_PinAltFunMode	  		= AF4;
	pinSDA.pinConfig.GPIO_PinOutputType    		= GPIO_OTYPE_OPENDRAIN;
	pinSDA.pinConfig.GPIO_PinOutputSpeed   	  	= GPIO_OSPEED_FAST;
	pinSDA.pinConfig.GPIO_PinPuPdControl   		= GPIO_PUPDR_NOTHING;
	gpio_Config(&pinSDA);

	accelSensor.pI2Cx  			= I2C1;
	accelSensor.i2c_mainClock   = I2C_MAIN_CLOCK_16_Mhz;
	accelSensor.i2c_mode		= eI2C_MODE_SM;
	accelSensor.slaveAddress    = ACCEL_ADDRESS;
	i2c_Config(&accelSensor);
}

/**/
void config_LedRGB(void)
{


		/*	LedRed*/
		LedRed.pGPIOx 							= 	GPIOC;
		LedRed.pinConfig.GPIO_PinNumber			=	PIN_6;
		LedRed.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
		LedRed.pinConfig.GPIO_PinOutputType		=	GPIO_OTYPE_PUSHPULL;
		LedRed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
		LedRed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
		LedRed.pinConfig.GPIO_PinAltFunMode 	=	AF2;


		gpio_Config(&LedRed);

		/*	LedGreen	*/
		LedGreen.pGPIOx 						= 	GPIOC;
		LedGreen.pinConfig.GPIO_PinNumber		=	PIN_7;
		LedGreen.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
		LedGreen.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
		LedGreen.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
		LedGreen.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
		LedGreen.pinConfig.GPIO_PinAltFunMode 	=	AF2;


		gpio_Config(&LedGreen);

		/*	LedBlue	*/
		LedBlue.pGPIOx 							= 	GPIOC;
		LedBlue.pinConfig.GPIO_PinNumber		=	PIN_9;
		LedBlue.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
		LedBlue.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
		LedBlue.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
		LedBlue.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
		LedBlue.pinConfig.GPIO_PinAltFunMode 	=	AF2;


		gpio_Config(&LedBlue);


		/* Configuracion del PWM */


		red_pwm.ptrTIMx = TIM3;
		red_pwm.config.channel = PWM_CHANNEL_1;
		red_pwm.config.periodo = 200;
		red_pwm.config.prescaler = 160; // freq
		red_pwm.config.duttyCicle = 100; /* Se define el ciclo de trabajo (dutty cycle) del PWM en 100 (50%) */

		/* Se carga el PWM con los parametros establecidos */
		pwm_Config(&red_pwm);
		/* Se inicia la se√±al PWM en el canal y timer configurados para el color rojo */
		pwm_Start_Signal(&red_pwm);

		green_pwm.ptrTIMx = TIM3;
		green_pwm.config.channel = PWM_CHANNEL_2;
		green_pwm.config.periodo = 200;
		green_pwm.config.prescaler = 160; // freq
		green_pwm.config.duttyCicle = 50; /* Se define el ciclo de trabajo (dutty cycle) del PWM en 100 (25%) */

		/* Se carga el PWM con los parametros establecidos */
		pwm_Config(&green_pwm);
		/* Se inicia la se√±al PWM en el canal y timer configurados para el color verde */
		pwm_Start_Signal(&green_pwm);

		blue_pwm.ptrTIMx = TIM3;
		blue_pwm.config.channel = PWM_CHANNEL_4;
		blue_pwm.config.periodo = 200;
		blue_pwm.config.prescaler = 160; // freq
		blue_pwm.config.duttyCicle = 15; /* Se define el ciclo de trabajo (dutty cycle) del PWM en 100 (7.5%) */

		/* Se carga el PWM con los parametros establecidos */
		pwm_Config(&blue_pwm);
		/* Se inicia la se√±al PWM en el canal y timer configurados para el color azul */
		pwm_Start_Signal(&blue_pwm);
}


void param_rango (int16_t dataAccel){
    /* Si el valor del acelerometro es menor o igual a -16438, se ajusta a un valor minimo de -16200 */
	if (dataAccel  <= -16438){
		dataAccel = -16200;
	}
    /* Si el valor del acelerometro es mayor a 16438, se ajusta a un valor maximo de 16438 */
	else if(dataAccel > 16438){
		dataAccel = 16438;
	}
    /* Se convierte el valor ajustado a un rango de 0 a 200, escalando el resultado */
	var_Accel = (dataAccel/165) + 100;

}
	/*
	 * Overwrite Function
	 **/
void Timer5_Callback(void){
	gpio_TooglePin(&userLed); // Cambia el estado del pin de la LED
	sendMsg = 1; // Activa la bandera para enviar un mensaje

}
void Timer2_Callback(void){//este callback permitir√° el switch de los digitos
	flag_updateAccel = 1;
}

void usart2_RxCallback(void){
	receivedChar = usart_getRxData();
}

/*
 *Esta funcion sirve para detectar problemas de parametros
 *incorrectos
 **/
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		// problems
	}
}











