/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * autor 		   : lbarreras
 * fecha 		   : 17/09/2024
 ******************************************************************************
 */
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "usart_driver_hal.h"
#include "i2c_driver_hal.h"
#include "pwm_driver_hal.h"


// Definicion de los handlers necesario
GPIO_Handler_t userLed = {0};

GPIO_Handler_t LedRed = {0};
GPIO_Handler_t LedGreen = {0};
GPIO_Handler_t LedBlue = {0};

// Comunicacion R232 con el PC, ya habilitada en el board ucleo
// Utiliza la conexion USB
USART_Handler_t commserial = {0};

GPIO_Handler_t pinTx = {0};
GPIO_Handler_t pinRx = {0};

/* Timers */
Timer_Handler_t blinkyTimer = {0};
Timer_Handler_t updateAccel= {0};


/* Pines para el I2C */
GPIO_Handler_t pinSCL = {0};
GPIO_Handler_t pinSDA = {0};
I2C_Handler_t accelSensor = {0};
uint8_t i2c_AuxBuffer = {0};


//variables
uint8_t flag_updateAccel = 0;
int16_t var_Accel = 0;

//Handlers para los tres timers que se pidieron
PWM_Handler_t red_pwm = {0};
PWM_Handler_t blue_pwm = {0};
PWM_Handler_t green_pwm = {0};



/* registros y valores relacionados con el MPU */
#define ACCEL_ADDRESS	0b1101001;	// 0xD1 -> Direccion del Accel con Logic_0
#define ACCEL_XOUT_H	59	// 0x3B
#define ACCEL_XOUT_L	60	// 0x3C
#define ACCEL_YOUT_H	61	// 0x3D
#define ACCEL_YOUT_L	62	// 0x3E
#define ACCEL_ZOUT_H	63	// 0x3F
#define ACCEL_ZOUT_L	64	// 0x40
#define PWM_MGMT_1		107
#define WHO_AM_I		117

uint8_t receivedChar = '\0';
uint8_t sendMsg = 0;

// Mensaje que se imprimen
char greetingMsg[] = "Taller V Rocks!\n";
char bufferData[64] = "Accel MPU-6050 testing...\n";

// Definicion de las cabeceras de las funciones del main
void initSystem(void);
void config_LedRGB(void);
void config_I2C(void);
void param_rango(int16_t dataAccel);

/**
 * Funcion principal del programa.
 * Esta funcion es el corazon del programa!!
 *
 * */
int main(void){

	// Inicializamos todos los elementos del sistema
	initSystem();

	config_LedRGB();

	config_I2C();

	usart_writeMsg(&commserial, greetingMsg);

	i2c_WriteSingleRegisters(&accelSensor, PWM_MGMT_1, 0x00);

	/* Loop forever */
	while(1){

		// El sistema siempre esta verificando si el valor de  rxData ha cambiado
		//	lo cual sucede en la ISR de la recepcion (RX).
		//	Si este valor deja de ser '\0' significa que se recibio un caracter
		//	por lo tanto entra en el bloque if para analizar que se recibio
		if(receivedChar != '\0'){
			if(receivedChar == 'm'){
				// Presentamos un mensaje
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';
			}

			if (receivedChar == 'w'){
				sprintf(bufferData, "WHO_AM_I? (r)\n");
				usart_writeMsg(&commserial, bufferData);

				i2c_AuxBuffer = i2c_ReadSingleRegister(&accelSensor, WHO_AM_I);
				sprintf(bufferData, "dataRead = 0x%x \n", (unsigned int) i2c_AuxBuffer);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';
			}

			else if (receivedChar == 'p'){
				sprintf(bufferData, "PWM_MGMT_1_state (r)\n");
				usart_writeMsg(&commserial, bufferData);

				i2c_AuxBuffer = i2c_ReadSingleRegister(&accelSensor, PWM_MGMT_1);
				sprintf(bufferData, "dataRead = 0x%x \n", (unsigned int) i2c_AuxBuffer);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';
			}

			else if (receivedChar == 'r'){
				sprintf(bufferData, "PWM_MGMT_1_reset (w)\n");
				usart_writeMsg(&commserial, bufferData);

				i2c_WriteSingleRegisters(&accelSensor, PWM_MGMT_1, 0x00);
				receivedChar = '\0';
			}

			else if(receivedChar == 'x'){
				sprintf(bufferData, "Axis x data  (r)\n ");
				usart_writeMsg(&commserial, bufferData);

				uint8_t AccelLX_low  = i2c_ReadSingleRegister(&accelSensor, ACCEL_XOUT_L);
				uint8_t AccelLX_high = i2c_ReadSingleRegister(&accelSensor, ACCEL_XOUT_H);
				int16_t AccelX = AccelLX_high << 8 |  AccelLX_low;
				sprintf(bufferData, "Accelx = %d \n",  (int) AccelX);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';

				}
			else if(receivedChar == 'y'){
				sprintf(bufferData, "Axis y data  (r)\n ");
				usart_writeMsg(&commserial, bufferData);

				uint8_t AccelLY_low  = i2c_ReadSingleRegister(&accelSensor, ACCEL_YOUT_L);
				uint8_t AccelLY_high = i2c_ReadSingleRegister(&accelSensor, ACCEL_YOUT_H);
				int16_t AccelY = AccelLY_high << 8 |  AccelLY_low;
				sprintf(bufferData, "AccelY = %d \n",  (int) AccelY);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';

				}
			else if(receivedChar == 'z'){
				sprintf(bufferData, "Axis z data  (r)\n ");
				usart_writeMsg(&commserial, bufferData);

				uint8_t AccelLZ_low  = i2c_ReadSingleRegister(&accelSensor, ACCEL_ZOUT_L);
				uint8_t AccelLZ_high = i2c_ReadSingleRegister(&accelSensor, ACCEL_ZOUT_H);
				int16_t AccelZ = AccelLZ_high << 8 |  AccelLZ_low;
				sprintf(bufferData, "AccelZ = %d \n",  (int) AccelZ);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';

				}
			else if(receivedChar == 'q'){
				sprintf(bufferData, "All 3 axis  (r)\n ");
				usart_writeMsg(&commserial, bufferData);

				uint8_t AccelData[6] = {0};
				i2c_ReadManyRegisters(&accelSensor, ACCEL_XOUT_H, AccelData, 6);
				int16_t AccelX = AccelData[0] << 8 | AccelData[1];
				int16_t AccelY = AccelData[2] << 8 | AccelData[3];
				int16_t AccelZ = AccelData[4] << 8 | AccelData[5];
				sprintf(bufferData, "Accel x,y,z -> %d  %d %d \n", (int) AccelX, (int) AccelY, (int) AccelZ);
				usart_writeMsg(&commserial, bufferData);
				receivedChar = '\0';
				}

			receivedChar = '\0';
		}
		if (flag_updateAccel){

			uint8_t AccelData[6] = {0};
			i2c_ReadManyRegisters(&accelSensor, ACCEL_XOUT_H, AccelData, 6);
			int16_t AccelX = AccelData[0] << 8 | AccelData[1];
			int16_t AccelY = AccelData[2] << 8 | AccelData[3];
			int16_t AccelZ = AccelData[4] << 8 | AccelData[5];
			sprintf(bufferData, "Accel x,y,z -> %d %d %d \n", (int) AccelX, (int) AccelY, (int) AccelZ);
			usart_writeMsg(&commserial, bufferData);
			receivedChar = '\0';

			 param_rango(AccelX);
			 pwm_Update_DuttyCycle(&red_pwm, var_Accel);

			 param_rango(AccelY);
			 pwm_Update_DuttyCycle(&green_pwm, var_Accel);

			 param_rango(AccelZ);
			 pwm_Update_DuttyCycle(&blue_pwm, var_Accel);
			 flag_updateAccel = 0;
			}
		   }
    return 0;
}
	/* Funcion encargada de la inicializacion del sistema */

void initSystem(void)
{
	/*	Configuramos el pin*/
	userLed.pGPIOx 							= 	GPIOA;
	userLed.pinConfig.GPIO_PinNumber		=	PIN_5;
	userLed.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);
	gpio_WritePin(&userLed, 1);


	blinkyTimer.pTIMx 							= TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period			=250;  //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer,SET);

	// Configuramos el Timer (refresco 10 ms)
	updateAccel.pTIMx								= TIM2;
	updateAccel.TIMx_Config.TIMx_Prescaler			= 1600; //	genera incremento  de 1 ms
	updateAccel.TIMx_Config.TIMx_Period 				= 500; 	//	de la mano con el prescaler
	updateAccel.TIMx_Config.TIMx_mode 				=TIMER_UP_COUNTER;
	updateAccel.TIMx_Config.TIMx_InterruptEnable	 	=TIMER_INT_ENABLE;
	timer_Config(&updateAccel);

	/* Encendemos los timers */
	timer_SetState(&updateAccel, TIMER_ON);

	/* Configuramos los pines del puerto serial
	 * pin sobre el que funciona el USART2 (TX) */
	pinTx.pGPIOx                          = GPIOA;
	pinTx.pinConfig.GPIO_PinNumber        = PIN_2;
	pinTx.pinConfig.GPIO_PinMode          = GPIO_MODE_ALTFN;
	pinTx.pinConfig.GPIO_PinAltFunMode	  = AF7;
	pinTx.pinConfig.GPIO_PinOutputSpeed   = GPIO_OSPEED_FAST;
	pinTx.pinConfig.GPIO_PinPuPdControl   = GPIO_PUPDR_NOTHING;

	/* Escribimos la configuracion en la memoria del MCU */
	gpio_Config(&pinTx);

	/* Pin sobre el que funciona el USART2 (RX) */
	pinRx.pGPIOx                          = GPIOA;
	pinRx.pinConfig.GPIO_PinNumber        = PIN_3;
	pinRx.pinConfig.GPIO_PinMode          = GPIO_MODE_ALTFN;
	pinRx.pinConfig.GPIO_PinAltFunMode	  = AF7;
	pinRx.pinConfig.GPIO_PinOutputType    = GPIO_OTYPE_PUSHPULL;
	pinRx.pinConfig.GPIO_PinOutputSpeed   = GPIO_OSPEED_FAST;
	pinRx.pinConfig.GPIO_PinPuPdControl   = GPIO_PUPDR_NOTHING;

	/* Escribimos la configuracion en la memoria del MCU */
	gpio_Config(&pinRx);



	//Configuramos el puerto serial (USART2)
	commserial.ptrUSARTx				= USART2;
	commserial.USART_Config.baudrate    = USART_BAUDRATE_19200;
	commserial.USART_Config.datasize	= USART_DATASIZE_8BIT;
	commserial.USART_Config.parity		= USART_PARITY_EVEN;
	commserial.USART_Config.stopbits	= USART_STOPBIT_1;
	commserial.USART_Config.mode 		= USART_MODE_RXTX;
	commserial.USART_Config.enableIntRX = USART_RX_INTERRUP_ENABLE;

	/* Escribimos la configuracion en la memoria del MCU */
	usart_Config(&commserial);

	usart_WriteChar(&commserial, '\0');

}

/**/
void config_I2C(void)
{
	pinSCL.pGPIOx 								= GPIOB;
	pinSCL.pinConfig.GPIO_PinNumber        		= PIN_6;
	pinSCL.pinConfig.GPIO_PinMode          		= GPIO_MODE_ALTFN;
	pinSCL.pinConfig.GPIO_PinAltFunMode	  		= AF4;
	pinSCL.pinConfig.GPIO_PinOutputType   		= GPIO_OTYPE_OPENDRAIN;
	pinSCL.pinConfig.GPIO_PinOutputSpeed   	  	= GPIO_OSPEED_FAST;
	pinSCL.pinConfig.GPIO_PinPuPdControl  		= GPIO_PUPDR_NOTHING;
	gpio_Config(&pinSCL);

	pinSDA.pGPIOx 								= GPIOB;
	pinSDA.pinConfig.GPIO_PinNumber        		= PIN_9;
	pinSDA.pinConfig.GPIO_PinMode          		= GPIO_MODE_ALTFN;
	pinSDA.pinConfig.GPIO_PinAltFunMode	  		= AF4;
	pinSDA.pinConfig.GPIO_PinOutputType    		= GPIO_OTYPE_OPENDRAIN;
	pinSDA.pinConfig.GPIO_PinOutputSpeed   	  	= GPIO_OSPEED_FAST;
	pinSDA.pinConfig.GPIO_PinPuPdControl   		= GPIO_PUPDR_NOTHING;
	gpio_Config(&pinSDA);

	accelSensor.pI2Cx  			= I2C1;
	accelSensor.i2c_mainClock   = I2C_MAIN_CLOCK_16_Mhz;
	accelSensor.i2c_mode		= eI2C_MODE_SM;
	accelSensor.slaveAddress    = ACCEL_ADDRESS;
	i2c_Config(&accelSensor);
}

/**/
void config_LedRGB(void)
{

		/*	LedRed*/
		LedRed.pGPIOx 							= 	GPIOC;
		LedRed.pinConfig.GPIO_PinNumber			=	PIN_6;
		LedRed.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
		LedRed.pinConfig.GPIO_PinOutputType		=	GPIO_OTYPE_PUSHPULL;
		LedRed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
		LedRed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
		LedRed.pinConfig.GPIO_PinAltFunMode 	=	AF2;


		gpio_Config(&LedRed);

		/*	LedGreen	*/
		LedGreen.pGPIOx 						= 	GPIOC;
		LedGreen.pinConfig.GPIO_PinNumber		=	PIN_7;
		LedGreen.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
		LedGreen.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
		LedGreen.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
		LedGreen.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
		LedGreen.pinConfig.GPIO_PinAltFunMode 	=	AF2;


		gpio_Config(&LedGreen);

		/*	LedBlue	*/
		LedBlue.pGPIOx 							= 	GPIOC;
		LedBlue.pinConfig.GPIO_PinNumber		=	PIN_9;
		LedBlue.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
		LedBlue.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
		LedBlue.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
		LedBlue.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
		LedBlue.pinConfig.GPIO_PinAltFunMode 	=	AF2;


		gpio_Config(&LedBlue);


		red_pwm.ptrTIMx = TIM3;
		red_pwm.config.channel = PWM_CHANNEL_1;
		red_pwm.config.periodo = 200;
		red_pwm.config.prescaler = 160;
		red_pwm.config.duttyCicle = 100;

		pwm_Config(&red_pwm);
		pwm_Start_Signal(&red_pwm);

		green_pwm.ptrTIMx = TIM3;
		green_pwm.config.channel = PWM_CHANNEL_2;
		green_pwm.config.periodo = 200;
		green_pwm.config.prescaler = 160;
		green_pwm.config.duttyCicle = 50;

		pwm_Config(&green_pwm);
		pwm_Start_Signal(&green_pwm);

		blue_pwm.ptrTIMx = TIM3;
		blue_pwm.config.channel = PWM_CHANNEL_4;
		blue_pwm.config.periodo = 200;
		blue_pwm.config.prescaler = 160;
		blue_pwm.config.duttyCicle = 15;

		pwm_Config(&blue_pwm);
		pwm_Start_Signal(&blue_pwm);
}


void param_rango (int16_t dataAccel){
	if (dataAccel  <= -16438){
		dataAccel = -16200;
	}else if(dataAccel > 16438){
		dataAccel = 16438;
	}
	var_Accel = (dataAccel/165) + 100;

}
	/*
	 * Overwrite Function
	 **/
void Timer5_Callback(void){
	gpio_TooglePin(&userLed);
	sendMsg = 1;

}
void Timer2_Callback(void){//este callback permitirá el switch de los digitos
	flag_updateAccel = 1;
}

void usart2_RxCallback(void){
	receivedChar = usart_getRxData();
}

/*
 *Esta funcion sirve para detectar problemas de parametros
 *incorrectos
 **/
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		// problems
	}
}











