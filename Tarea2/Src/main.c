/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 */
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include <stm32f4xx.h>
#include <stdint.h>
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"








//Handlers GPIO, para los pines. Lo de toda la vida.
GPIO_Handler_t userLed = {0}; //	PinA5
GPIO_Handler_t LedA = {0}; //	PinC7
GPIO_Handler_t LedB = {0}; //	PinA9
GPIO_Handler_t LedC = {0}; //	PinCB6
GPIO_Handler_t LedD = {0}; //	PinC6
GPIO_Handler_t LedE = {0}; //	PinB9
GPIO_Handler_t LedF = {0}; //	PinA6
GPIO_Handler_t LedG = {0}; //	PinA0
GPIO_Handler_t switcheo= {0};  // PinA7



// Definir variables
uint8_t contador = 0;
uint8_t unidades = 0;
uint8_t decenas = 0;

//Handlers para los tres timers que se pidieron
Timer_Handler_t contador_segundos = {0};
Timer_Handler_t blinkyTimer = {0};
Timer_Handler_t display = {0};


/*
 * The main function, where EVERYTHING HAPPENS. The magic happens...
 */
int main(void)
{
	/*	Configuramos el pin*/
	userLed.pGPIOx 							= 	GPIOA;
	userLed.pinConfig.GPIO_PinNumber		=	PIN_5;
	userLed.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);


	/*esto es lo nuevo, esta forma de cargar las configuraciones de los Handlers de los timers es parecida a
	 * los del GPIO, la primera fila para definir el que queremos usar (quedan a eleccion del programador) no obstante
	 * en la tarea se nos pide que usemos ciertos timers con cierto numero especifico de bits, 32 para unos y 16 para otros.
	 * Por tanto se uso esta escogencia. En la segunda fila del prescaler se usa el 16000 para que durante todo este
	 * proceso de interrupciones, y teniendo que el micro va a 16MHz, el 16000 divide esta cifra y la deja en un formato de
	 * 1 ms. Este 1 ms se multiplica por el periodo, y lo elegimos segun lo que requiramos. Para el TIM2 pusimos 1000
	 * que 1ms * 1000, nos da 1000ms lo que es igual a 1 segundo, lo que completa nuestro deseo que este contador de segundos
	 * en efecto, cuente segundos. Para el blinky de manera "estandar" hacemos que vaya a un ratio de 250 ms.
	 */

	contador_segundos.pTIMx 							= TIM2;
	contador_segundos.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	contador_segundos.TIMx_Config.TIMx_Period			=1000;  //	se pone 1000 porque en combinacion con el prescaler que es 16000, esa division da para que el timer vaya a 1000ms
	contador_segundos.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	contador_segundos.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&contador_segundos);

	//	Encedemos el Timer.
	timer_SetState(&contador_segundos,SET);

	blinkyTimer.pTIMx 							= TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period			=250;  //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer,SET);

	display.pTIMx 							= TIM3;
	display.TIMx_Config.TIMx_Prescaler		=16000;  //	Genera incrementos de 1ms
	display.TIMx_Config.TIMx_Period			=15;  //	60FPS ultra calidad gamer.
	display.TIMx_Config.TIMx_mode			=TIMER_UP_COUNTER;  //
	display.TIMx_Config.TIMx_InterruptEnable	=TIMER_INT_ENABLE;  //


	/*	Configuramos el Timer */
	timer_Config(&display);

	//	Encedemos el Timer.
	timer_SetState(&display,SET);


	/* Configuramos el pin. Aqui se configuran los pins uno por uno, para este driver
	 * los datos mas importantes a tener en cuenta es el puerto (A,B,C...), el numero del pin y el modo del pin.
	 * si le damos clic derecho encima a las configuraciones en azul de la izquierda nos lleva al hal.h
	 * donde se nos muestra la estructura interna del codigo y las distinas formas en las que podiamos
	 * asignar modos, velocidades, etc. */

	userLed.pGPIOx 							= 	GPIOA;
	userLed.pinConfig.GPIO_PinNumber		=	PIN_5;
	userLed.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;




	gpio_Config(&userLed);


	/*configuramos los pines, y cargamos las configuraciones asi como aprendimos en la tarea #1, nada nuevo. Aqui
	 * los "leds" son las divisiones que tiene 7segmentos (a,b,c,d....)
	 */

	/*	LedA	*/
	LedA.pGPIOx 							= 	GPIOC;
	LedA.pinConfig.GPIO_PinNumber		=	PIN_7;
	LedA.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedA.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedA.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedA.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedA);


	/*	LedB	*/
	LedB.pGPIOx 							= 	GPIOA;
	LedB.pinConfig.GPIO_PinNumber		=	PIN_9;
	LedB.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedB.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedB.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedB.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedB);

	/*	LedC*/
	LedC.pGPIOx 							= 	GPIOB;
	LedC.pinConfig.GPIO_PinNumber		=	PIN_6;
	LedC.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedC.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedC.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedC.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedC);

	/*	LedD*/
	LedD.pGPIOx 							= 	GPIOC;
	LedD.pinConfig.GPIO_PinNumber		=	PIN_6;
	LedD.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedD.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedD.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedD.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedD);

	/*	LedE*/
	LedE.pGPIOx 							= 	GPIOB;
	LedE.pinConfig.GPIO_PinNumber		=	PIN_9;
	LedE.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedE.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedE.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedE.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedE);

	/*	LedF*/
	LedF.pGPIOx 							= 	GPIOA;
	LedF.pinConfig.GPIO_PinNumber		=	PIN_6;
	LedF.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedF.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedF.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_MEDIUM;
	LedF.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedF);

	/*	LedG*/
	LedG.pGPIOx 							= 	GPIOB;
	LedG.pinConfig.GPIO_PinNumber		=	PIN_8;
	LedG.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	LedG.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	LedG.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_FAST;
	LedG.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&LedG);

	/*	switcheo */
	switcheo.pGPIOx 							= 	GPIOA;
	switcheo.pinConfig.GPIO_PinNumber		=	PIN_7;
	switcheo.pinConfig.GPIO_PinMode			=	GPIO_MODE_OUT;
	switcheo.pinConfig.GPIO_PinOutputType	=	GPIO_OTYPE_PUSHPULL;
	switcheo.pinConfig.GPIO_PinOutputSpeed	=	GPIO_OSPEED_FAST;
	switcheo.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;

	gpio_Config(&switcheo);








	while(1){
		if (contador == 61){
			contador = 0;
		}
		//almacenamos en las variables definidas anteriormente, una diferenciacion entre las unidades que nos genera el numero y las decenas del mismo, este numero es contador, que va sumando de a 1 seg.
		unidades = contador%10;
		decenas = contador/10;

		/* aqui decidimos usar WritePin "a la fuerza" es decir, sabemos que partes del 7segmentos se encienden
		 * para cada numero, entonces es solo plantear que leds encender para cada numero, haciendo esto uno
		 * para las decenas y otro para las unidades. Tambien se pudo usar una variable auxiliar como se hizo
		 * en la tarea #1, pero con esto aunque algo tosco se muestre, ahorra codigo y es mas eficiente.
		 */


		/* error en esto, se genera un fantasma, ya que esta toogleando y haciendo la limpieza al tiempo*/
		if (gpio_ReadPin(&switcheo)== 1){
			gpio_WritePin(&LedA, 0);
			gpio_WritePin(&LedB, 0);
			gpio_WritePin(&LedC, 0);
			gpio_WritePin(&LedD, 0);
			gpio_WritePin(&LedE, 0);
			gpio_WritePin(&LedF, 0);
			gpio_WritePin(&LedG, 0);
			if (unidades == 0){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 1);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 0);

			}
			else if (unidades == 1){
				gpio_WritePin(&LedA, 0);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 0);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 0);
				gpio_WritePin(&LedG, 0);
			}
			else if (unidades == 2){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 0);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 1);
				gpio_WritePin(&LedF, 0);
				gpio_WritePin(&LedG, 1);
			}
			else if (unidades == 3){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 0);
				gpio_WritePin(&LedG, 1);
			}
			else if (unidades == 4){
				gpio_WritePin(&LedA, 0);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 0);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}
			else if (unidades == 5){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 0);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}
			else if (unidades == 6){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 0);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 1);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}
			else if (unidades == 7){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 0);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 0);
				gpio_WritePin(&LedG, 0);
			}
			else if (unidades == 8){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 1);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}
			else {
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 0);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}
		}
		else {
			gpio_WritePin(&LedA, 0);
			gpio_WritePin(&LedB, 0);
			gpio_WritePin(&LedC, 0);
			gpio_WritePin(&LedD, 0);
			gpio_WritePin(&LedE, 0);
			gpio_WritePin(&LedF, 0);
			gpio_WritePin(&LedG, 0);
			if (decenas == 0){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 1);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 0);

			}
			else if (decenas == 1){
				gpio_WritePin(&LedA, 0);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 0);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 0);
				gpio_WritePin(&LedG, 0);
			}
			else if (decenas == 2){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 0);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 1);
				gpio_WritePin(&LedF, 0);
				gpio_WritePin(&LedG, 1);
			}
			else if (decenas == 3){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 0);
				gpio_WritePin(&LedG, 1);
			}
			else if (decenas == 4){
				gpio_WritePin(&LedA, 0);
				gpio_WritePin(&LedB, 1);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 0);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}
			else if (decenas == 5){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 0);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 0);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}
			else if (decenas == 6){
				gpio_WritePin(&LedA, 1);
				gpio_WritePin(&LedB, 0);
				gpio_WritePin(&LedC, 1);
				gpio_WritePin(&LedD, 1);
				gpio_WritePin(&LedE, 1);
				gpio_WritePin(&LedF, 1);
				gpio_WritePin(&LedG, 1);
			}


		}
	}
}



/*
 *  Overwrite function
 **/




/* en este callback se sube y baja la bandera (UIF) permitiendo que se dé la interrupcion y no quede
 * interrumpido indefinidamente, al mismo tiempo siendo este el timer que usamos para nuestro contador de segundos
 * hacemos que durante esta interrupcion (de 1 seg, valga la redundancia) se nos sume a una variable auxiliar que llamamos
 * contador, que es la que nos ayuda en la parte del codigo del display, para ir mostrando los numeros en el momento que
 * necesitamos
 */

void Timer2_Callback(void){

	contador ++;
}



void Timer3_Callback(void){
	gpio_TooglePin(&switcheo);
}

/* este el callback del Led de estado, usamos el TooglePin para que se enciende y se apague, es la unico para lo
 * que no sirve esta interrupcion. A grandes rasgos sirve para saber que el sistema funciona.
 */
void Timer5_Callback(void){
	gpio_TooglePin(&userLed);
}





/*
 *  Esta funcion sirve para detectar problemas de parametros
 *  incorrectos al momento de ejecutar un programa.
   */
void assert_failed(uint8_t* file, uint32_t line){
	while(1){
		//problems...
	}
}
