/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * autor 		   : lbarreras
 * fecha 		   : 17/09/2024
 ******************************************************************************
 */
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "usart_driver_hal.h"
#include "i2c_driver_hal.h"
#include "pwm_driver_hal.h"
#include "exti_driver_hal.h"

//Handlers

Timer_Handler_t blinkyTimer = { 0 };
GPIO_Handler_t userLed = { 0 }; 	//	PinA5
GPIO_Handler_t botonDerecho = { 0 }; 		//	PinC8
GPIO_Handler_t botonCentro = { 0 }; 		//	PinB8
GPIO_Handler_t botonIzquierdo = { 0 }; 		//	PinB8
EXTI_Config_t exti_botonDerecho = { 0 };		//	Pin
EXTI_Config_t exti_botonCentro = { 0 };		//	Pin
EXTI_Config_t exti_botonIzquierdo = { 0 };		//	Pin

//Variables

//flags
uint8_t flag_botonDerecho;
uint8_t flag_botonCentro;
uint8_t flag_botonIzquierdo;

void init_system(void);

int main(void) {

	init_system();

	while (1) {

		if (flag_botonDerecho == 10) {
			flag_botonDerecho = 0;


		}

		if (flag_botonCentro == 10) {
			flag_botonCentro = 0;

		}
		if (flag_botonIzquierdo == 10) {
			flag_botonIzquierdo = 0;

		}

	}

}

/*	Configuramos el pin*/

void init_system(void) {

	/*	Configuramos los pines*/

	/* userLed */
	userLed.pGPIOx = GPIOA;
	userLed.pinConfig.GPIO_PinNumber = PIN_5;
	userLed.pinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType = GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);

	/*configuramos los pines, y cargamos las configuraciones asi como aprendimos en la tarea #1, nada nuevo. Aqui
	 * los "leds" son las divisiones que tiene el 7segmentos (a,b,c,d....), entonces los pines van a estas divisiones
	 * y encienden estos "leds" enumerados alfabeticamente. El 7segmentos tambien puede verse como un pin muy grande con
	 * varias conexiones.
	 */

	/*	botonDerecho	*/
	botonDerecho.pGPIOx = GPIOC;
	botonDerecho.pinConfig.GPIO_PinNumber = PIN_8;
	botonDerecho.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonDerecho);

	/*	botonCentro	*/
	botonCentro.pGPIOx = GPIOC;
	botonCentro.pinConfig.GPIO_PinNumber = PIN_6;
	botonCentro.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonCentro);

	/*	botonIzquierdo*/
	botonIzquierdo.pGPIOx = GPIOC;
	botonIzquierdo.pinConfig.GPIO_PinNumber = PIN_5;
	botonIzquierdo.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonIzquierdo);

	/*Configuracion de los botones/EXTI */

	exti_botonDerecho.pGPIOHandler = &botonDerecho;
	exti_botonDerecho.edgeType = EXTERNAL_INTERRUPT_RISING_EDGE;

	exti_Config(&exti_botonDerecho);

	exti_botonCentro.pGPIOHandler = &botonCentro;
	exti_botonCentro.edgeType = EXTERNAL_INTERRUPT_RISING_EDGE;

	exti_Config(&exti_botonCentro);

	exti_botonIzquierdo.pGPIOHandler = &botonIzquierdo;
	exti_botonIzquierdo.edgeType = EXTERNAL_INTERRUPT_RISING_EDGE;

	exti_Config(&exti_botonIzquierdo);

	//Timer del Blinky
	blinkyTimer.pTIMx = TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler = 16000; //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period = 250; //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode = TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable = TIMER_INT_ENABLE;  //

	/*	Configuramos el Timer */
	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer, SET);

}

//Callbacks del EXTI.

void callback_ExtInt8(void) {

	flag_botonDerecho += 1;
}

void callback_ExtInt6(void) {

	flag_botonCentro += 1;
}

void callback_ExtInt5(void) {

	flag_botonIzquierdo += 1;
}



//Callbacks de los timers

/* este el callback del Led de estado, usamos el TooglePin para que se enciende y se apague, es la unico para lo
 * que nos sirve esta interrupcion. A grandes rasgos sirve para saber que el sistema funciona.

 Ademas de eso, agregamos la bandera para que se de la conversion de adc y la inicializacion de la variable sendMsg*/
void Timer5_Callback(void){
	gpio_TooglePin(&userLed);

}

/*
 *Esta funcion sirve para detectar problemas de parametros
 *incorrectos
 **/
void assert_failed(uint8_t *file, uint32_t line) {
	while (1) {
		// problems
	}
}

