/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 * autor 		   : lbarreras
 * fecha 		   : 17/09/2024
 ******************************************************************************
 */

/* ============== GUITAR HERO LEGENDS OF ROCK-8BIT ============== */

#include <stdint.h>
#include <math.h>
#include <stdbool.h>
#include <string.h>
#include "stm32f4xx.h"
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"
#include "usart_driver_hal.h"
#include "i2c_driver_hal.h"
#include "pwm_driver_hal.h"
#include "exti_driver_hal.h"
#include "systick_driver_hal.h"
#include "oled_driver.h"







//Handlers

Timer_Handler_t blinkyTimer = { 0 };
GPIO_Handler_t userLed = { 0 }; 	//	PinA5
GPIO_Handler_t botonDerecho = { 0 }; 		//	PinC8
GPIO_Handler_t botonCentro = { 0 }; 		//	PinB8
GPIO_Handler_t botonIzquierdo = { 0 }; 		//	PinB8
GPIO_Handler_t gpio_buzzer = { 0 }; 		//
EXTI_Config_t exti_botonDerecho = { 0 };		//	Pin
EXTI_Config_t exti_botonCentro = { 0 };		//	Pin
EXTI_Config_t exti_botonIzquierdo = { 0 };		//	Pin
PWM_Handler_t pwm_buzzer = { 0 };	// PinB2

/* Elementos para la comunicacion serial  llevar nuevo */
uint8_t usart2DataReceived = 0;
char	bufferMsg[64] = {0};
USART_Handler_t commSerial = {0};
GPIO_Handler_t pinTx = {0};
GPIO_Handler_t pinRx = {0};


/* Handlers para el I2C */
GPIO_Handler_t pinSCL = {0}; //PinB6
GPIO_Handler_t pinSDA = {0}; //PinB9
I2C_Handler_t screen = {0};
uint8_t i2c_AuxBuffer = {0};
I2C_Handler_t i2c_handler = {0};


//variables
uint8_t flag_updateAccel = 0; //bandera para la actualizacion de los datos entregados por el Acelerometro
int16_t var_Accel = 0; // variable global del acel. para la funcion que se uso de parametrizar


//Variables

//flags
uint8_t flag_botonDerecho;
uint8_t flag_botonCentro;
uint8_t flag_botonIzquierdo;

//buzzer
// change this to make the song slower or faster
uint8_t tempo = 0;

// change this to whichever pin you want to use
uint8_t buzzer = 0;





#define ACCEL_ADDRESS	0b0111100;	// Slave address bit (SA0)-> Direccion de la pantalla (buscado en internet)


//Notas musicales
#define NOTE_B0  31
#define NOTE_C1  33
#define NOTE_CS1 35
#define NOTE_D1  37
#define NOTE_DS1 39
#define NOTE_E1  41
#define NOTE_F1  44
#define NOTE_FS1 46
#define NOTE_G1  49
#define NOTE_GS1 52
#define NOTE_A1  55
#define NOTE_AS1 58
#define NOTE_B1  62
#define NOTE_C2  65
#define NOTE_CS2 69
#define NOTE_D2  73
#define NOTE_DS2 78
#define NOTE_E2  82
#define NOTE_F2  87
#define NOTE_FS2 93
#define NOTE_G2  98
#define NOTE_GS2 104
#define NOTE_A2  110
#define NOTE_AS2 117
#define NOTE_B2  123
#define NOTE_C3  131
#define NOTE_CS3 139
#define NOTE_D3  147
#define NOTE_DS3 156
#define NOTE_E3  165
#define NOTE_F3  175
#define NOTE_FS3 185
#define NOTE_G3  196
#define NOTE_GS3 208
#define NOTE_A3  220
#define NOTE_AS3 233
#define NOTE_B3  247
#define NOTE_C4  262
#define NOTE_CS4 277
#define NOTE_D4  294
#define NOTE_DS4 311
#define NOTE_E4  330
#define NOTE_F4  349
#define NOTE_FS4 370
#define NOTE_G4  392
#define NOTE_GS4 415
#define NOTE_A4  440
#define NOTE_AS4 466
#define NOTE_B4  494
#define NOTE_C5  523
#define NOTE_CS5 554
#define NOTE_D5  587
#define NOTE_DS5 622
#define NOTE_E5  659
#define NOTE_F5  698
#define NOTE_FS5 740
#define NOTE_G5  784
#define NOTE_GS5 831
#define NOTE_A5  880
#define NOTE_AS5 932
#define NOTE_B5  988
#define NOTE_C6  1047
#define NOTE_CS6 1109
#define NOTE_D6  1175
#define NOTE_DS6 1245
#define NOTE_E6  1319
#define NOTE_F6  1397
#define NOTE_FS6 1480
#define NOTE_G6  1568
#define NOTE_GS6 1661
#define NOTE_A6  1760
#define NOTE_AS6 1865
#define NOTE_B6  1976
#define NOTE_C7  2093
#define NOTE_CS7 2217
#define NOTE_D7  2349
#define NOTE_DS7 2489
#define NOTE_E7  2637
#define NOTE_F7  2794
#define NOTE_FS7 2960
#define NOTE_G7  3136
#define NOTE_GS7 3322
#define NOTE_A7  3520
#define NOTE_AS7 3729
#define NOTE_B7  3951
#define NOTE_C8  4186
#define NOTE_CS8 4435
#define NOTE_D8  4699
#define NOTE_DS8 4978
#define REST 1

void tone(PWM_Handler_t *ptrPwmHandler, uint16_t newFreq, uint16_t duration);
void noTone(PWM_Handler_t *ptrPwmHandler);
void init_system(void);

int main(void) {
	init_system();

	// change this to make the song slower or faster
	tempo = 108;

	// change this to whichever pin you want to use
	buzzer = 11;

	// notes of the melody followed by the duration.
	// a 4 means a quarter note, 8 an eighteenth , 16 sixteenth, so on
	// !!negative numbers are used to represent dotted notes,
	// so -4 means a dotted quarter note, that is, a quarter plus an eighteenth!!

	//Arreglar loop infinito
	int melody[2048] = {

	REST, 4, NOTE_G5, 4,
	NOTE_A5, 4, NOTE_AS5, 4,
	NOTE_A5, 4, NOTE_F5, 4,
	NOTE_A5, 4, NOTE_G5, 4,
	REST, 4, NOTE_G5, 4,
	NOTE_A5, 4, NOTE_AS5, 4,
	NOTE_C6, 4, NOTE_AS5, 4,

	NOTE_A5, 4, NOTE_G5,
			4, //8
			REST, 4, NOTE_G5, 4,
			NOTE_A5, 4, NOTE_AS5, 4,
			NOTE_A5, 4, NOTE_F5, 4,
			NOTE_A5, 4, NOTE_G5, 4,
			NOTE_D6, 4, REST, 8, NOTE_C6, 8,
			REST, 4, NOTE_AS5, 4,

			NOTE_A5, 4, NOTE_AS5, 8, NOTE_C6,
			8, //15
			NOTE_F6, 8, REST, 8, REST, 4,
			NOTE_G5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,

			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5,
			16, //20
			NOTE_G5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,

			NOTE_G5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5,
			16, //25
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_AS5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,

			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_C6, 16, NOTE_C6, 16, NOTE_F6, 16, NOTE_D6, 8, REST, 16, REST,
			8,
			REST, 4, NOTE_C6, 16, NOTE_AS5, 16,

			NOTE_C6, -8, NOTE_F6, -8, NOTE_D6,
			-4, //35
			NOTE_C6, 8, NOTE_AS5, 8,
			NOTE_C6, 8, NOTE_F6, 16, NOTE_D6, 8, REST, 16, REST, 8,
			REST, 4, NOTE_C6, 8, NOTE_D6, 8,
			NOTE_DS6, -8, NOTE_F6, -8,

			NOTE_D6, -8, REST, 16, NOTE_DS6, 8, REST,
			8, //40
			NOTE_C6, 8, NOTE_F6, 16, NOTE_D6, 8, REST, 16, REST, 8,
			REST, 4, NOTE_C6, 8, NOTE_AS5, 8,
			NOTE_C6, -8, NOTE_F6, -8, NOTE_D6, -4,
			NOTE_C6, 8, NOTE_AS5, 8,

			NOTE_C6, 8, NOTE_F6, 16, NOTE_D6, 8, REST, 16, REST,
			8, //45
			REST, 4, NOTE_C6, 8, NOTE_D6, 8,
			NOTE_DS6, -8, NOTE_F6, -8,
			NOTE_D5, 8, NOTE_FS5, 8, NOTE_F5, 8, NOTE_A5, 8,
			NOTE_A5, -8, NOTE_G5, -4,

			NOTE_A5, -8, NOTE_G5,
			-4, //50
			NOTE_A5, -8, NOTE_G5, -4,
			NOTE_AS5, 8, NOTE_A5, 8, NOTE_G5, 8, NOTE_F5, 8,
			NOTE_A5, -8, NOTE_G5, -8, NOTE_D5, 8,
			NOTE_A5, -8, NOTE_G5, -8, NOTE_D5, 8,
			NOTE_A5, -8, NOTE_G5, -8, NOTE_D5, 8,

			NOTE_AS5, 4, NOTE_C6, 4, NOTE_A5, 4, NOTE_AS5, 4,
			NOTE_G5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5,
			16, //56 //r
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,

			NOTE_G5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5,
			16, //61
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_G5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,

			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5,
			16, //66
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,
			NOTE_AS5, 16, NOTE_D5, 16, NOTE_D6, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16,
			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_A5, 16,
			NOTE_D5, 16, NOTE_G5, 16, NOTE_D5, 16,

			NOTE_A5, 16, NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5, 16, NOTE_C6, 16,
			NOTE_D5, 16, NOTE_AS5, 16, NOTE_D5,
			16, //71 //
			NOTE_A5, 16, NOTE_D5, 16, NOTE_F5, 16, NOTE_D5, 16, NOTE_A5, 8,
			NOTE_G5, 32, NOTE_A5, 32, NOTE_AS5, 32, NOTE_C6, 32,
			NOTE_D6, 16, NOTE_G5, 16, NOTE_AS5, 16, NOTE_G5, 16, NOTE_C6, 16,
			NOTE_G5, 16, NOTE_D6, 16, NOTE_G5, 16,
			NOTE_C6, 16, NOTE_G5, 16, NOTE_A5, 16, NOTE_G5, 16, NOTE_F6, 16,
			NOTE_G5, 16, NOTE_D6, 16, NOTE_DS5, 16,
			NOTE_D6, 4, REST, 4,

			NOTE_C5, 8, REST, 8, NOTE_A4, -16, NOTE_AS4, -16, NOTE_C5,
			16, //76
			NOTE_D6, 16, NOTE_G4, 16, NOTE_AS4, 16, NOTE_G4, 16, NOTE_C5, 16,
			NOTE_G4, 16, NOTE_D6, 16, NOTE_G4, 16,
			NOTE_C6, 16, NOTE_F4, 16, NOTE_A4, 16, NOTE_F4, 16, NOTE_F5, 16,
			NOTE_F4, 16, NOTE_D6, 16, NOTE_DS4, 16,
			NOTE_D6, 16, REST, 8, NOTE_E4, 16, NOTE_F4, 16,

			//change of key B Major A# C# D# F# G#
			NOTE_GS4, 8, REST, 8, NOTE_AS4, 8, REST, 8,

			NOTE_DS5, 16, NOTE_GS4, 16, NOTE_B4, 16, NOTE_GS4, 16, NOTE_CS5, 16,
			NOTE_GS4, 16, NOTE_DS5, 16, NOTE_GS4,
			16, //81
			NOTE_CS5, 16, NOTE_FS4, 16, NOTE_AS4, 16, NOTE_FS4, 16, NOTE_FS5,
			16, NOTE_FS4, 16, NOTE_DS5, 16, NOTE_E5, 16,
			NOTE_D5, 4, REST, 4,
			NOTE_CS5, 8, REST, 8, NOTE_AS4, -16, NOTE_B4, -16, NOTE_CS5, 16,
			NOTE_DS5, 16, NOTE_GS4, 16, NOTE_B4, 16, NOTE_GS4, 16, NOTE_CS5, 16,
			NOTE_GS4, 16, NOTE_DS5, 16, NOTE_GS4, 16,

			NOTE_CS5, 16, NOTE_FS4, 16, NOTE_AS4, 16, NOTE_FS4, 16, NOTE_FS5,
			16, NOTE_FS4, 16, NOTE_DS5, 16, NOTE_E5, 16,
			NOTE_DS5, 4, REST, 8, NOTE_DS5, 16, NOTE_E5, 16,
			NOTE_FS5, 16, NOTE_CS5, 16, NOTE_E5, 16, NOTE_CS4, 16, NOTE_DS5, 16,
			NOTE_E5, 16, NOTE_G5, 16, NOTE_AS5, 16,
			NOTE_GS5, 16, NOTE_DS5, 16, NOTE_DS6, 16, NOTE_DS5, 16, NOTE_CS6,
			16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,

			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_AS5, 16,
			NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5,
			16, //90
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_CS6, 16,
			NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_FS5, 16, NOTE_DS5, 16, NOTE_AS5,
			16, NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5, 16,
			NOTE_GS5, 16, NOTE_DS5, 16, NOTE_DS6, 16, NOTE_DS5, 16, NOTE_CS6,
			16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,

			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_AS5, 16,
			NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5,
			16, //94
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_CS6, 16,
			NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_FS5, 16, NOTE_DS5, 16, NOTE_AS5,
			16, NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5, 16,
			NOTE_GS5, 16, NOTE_DS5, 16, NOTE_DS6, 16, NOTE_DS5, 16, NOTE_CS6,
			16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,

			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_AS5, 16,
			NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5,
			16, //98
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_CS6, 16,
			NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_FS5, 16, NOTE_DS5, 16, NOTE_AS5,
			16, NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5, 16,
			NOTE_GS5, 16, NOTE_DS5, 16, NOTE_DS6, 16, NOTE_DS5, 16, NOTE_CS6,
			16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,

			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_AS5, 16,
			NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5,
			16, //102
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16, NOTE_CS6, 16,
			NOTE_DS5, 16, NOTE_B5, 16, NOTE_DS5, 16,
			NOTE_AS5, 16, NOTE_DS5, 16, NOTE_FS5, 16, NOTE_DS5, 16, NOTE_AS5,
			16, NOTE_DS5, 16, NOTE_GS5, 16, NOTE_DS5, 16,

			NOTE_CS6, 8, NOTE_FS6, 16, NOTE_DS6, 8, REST, 16, REST, 8, //107
			REST, 4, NOTE_CS6, 8, NOTE_B5, 8,
			NOTE_CS6, -8, NOTE_FS6, -8, NOTE_DS6, -4,
			NOTE_CS6, 8, NOTE_B5, 8,
			NOTE_CS6, 8, NOTE_FS6, 16, NOTE_DS6, 8, REST, 16, REST, 8,
			REST, 4, NOTE_CS6, 8, NOTE_B5, 8,
			NOTE_E6, -8, NOTE_F6, -8,

			NOTE_DS6, -8, REST, 16, NOTE_E6, 8, REST, 16, REST, 16, //112
			NOTE_CS6, 8, NOTE_FS6, 16, NOTE_DS6, 8, REST, 16, REST, 8,
			REST, 4, NOTE_CS6, 8, NOTE_B5, 8,
			NOTE_CS6, -8, NOTE_FS6, -8, NOTE_DS6, -4,
			NOTE_CS6, 8, NOTE_B5, 8,

			NOTE_CS6, 8, NOTE_FS6, 16, NOTE_DS6, 8, REST, 16, REST, 8, //117
			REST, 4, NOTE_CS5, 8, NOTE_DS5, 8,
			NOTE_E5, -8, NOTE_F5, -8,
			NOTE_DS5, 8, NOTE_G5, 8, NOTE_GS5, 8, NOTE_AS5, 8,
			NOTE_AS5, -8, NOTE_GS5, -8,

			NOTE_AS5, -8, NOTE_GS5, -8, //122
			NOTE_AS5, -8, NOTE_GS5, -8,
			NOTE_B6, 8, NOTE_AS5, 8, NOTE_GS5, 8, NOTE_FS5, 8,
			NOTE_AS5, -8, NOTE_GS6, -8, NOTE_DS5, 8,
			NOTE_AS5, -8, NOTE_GS6, -8, NOTE_DS5, 8,
			NOTE_AS5, -8, NOTE_GS6, -8, NOTE_DS5, 8,

			NOTE_B5, 8, NOTE_CS6, 8, NOTE_AS5, 8, NOTE_B5, 8, //128
			NOTE_GS5, 8, REST, 8, REST, 16 };

	// sizeof gives the number of bytes, each int value is composed of two bytes (16 bits)
	// there are two values per note (pitch and duration), so for each note there are four bytes
	int16_t notes = sizeof(melody) / 2;

	// this calculates the duration of a whole note in ms
	int16_t wholenote = (60000 * 4) / tempo;

	int16_t divider = 0;
	int16_t noteDuration = 0;

	// iterate over the notes of the melody.
	// Remember, the array is twice the number of notes (notes + durations)
	for (int16_t thisNote = 0; thisNote < notes * 2; thisNote = thisNote + 2) {

		// calculates the duration of each note
		divider = melody[thisNote + 1];
		if (divider > 0) {
			// regular note, just proceed
			noteDuration = (wholenote) / divider;
		} else if (divider < 0) {
			// dotted notes are represented with negative durations!!
//			noteDuration = (wholenote) / abs(divider);
			noteDuration = (wholenote) / divider;
			noteDuration *= -1.5; // increases the duration in half for dotted notes
		}

		// we only play the note for 90% of the duration, leaving 10% as a pause
		tone(&pwm_buzzer, melody[thisNote], noteDuration * 0.9);

		// Wait for the specief duration before playing the next note.
		delay_ms(noteDuration);

		// stop the waveform generation before the next note.
		noTone(&pwm_buzzer);
	}

	while (1) {



		if (flag_botonDerecho == 10) {
			flag_botonDerecho = 0;

		}

		if (flag_botonCentro == 10) {
			flag_botonCentro = 0;

		}
		if (flag_botonIzquierdo == 10) {
			flag_botonIzquierdo = 0;




			/* Prueba del USART */
			if (usart2DataReceived == 't'){

				usart_writeMsg(&commSerial, "\r\n");
				usart_writeMsg(&commSerial, "¿Probando? ¡Funciona!  \n\r");
				usart2DataReceived = '\0';
			}


			/* Prueba comunicación serial con la pantalla */
			if (usart2DataReceived == 'a'){

				usart_writeMsg(&commSerial, "\r\n");
				usart_writeMsg(&commSerial, "Intento de comunicación \r\n");
				usart2DataReceived = '\0';

				uint8_t auxRead = 0;


				usart_writeMsg(&commSerial, "\r\n");
				sprintf(bufferMsg, "Respuesta Slave: %u\r\n", (auxRead >> 6 & 1));
				usart_writeMsg(&commSerial, bufferMsg);

				usart2DataReceived = '\0';


			}

			/* Encender la OLED */
			if (usart2DataReceived == '1'){

				oled_onDisplay(&i2c_handler);
				usart_writeMsg(&commSerial, "\r\n");
				usart_writeMsg(&commSerial, "OLED encendida \r\n");

				usart2DataReceived = '\0';
			}

			/* Apagar la OLED */
			if (usart2DataReceived == '2'){

				oled_offDisplay(&i2c_handler);
				usart_writeMsg(&commSerial, "\r\n");
				usart_writeMsg(&commSerial, "OLED apagada \r\n");

				usart2DataReceived = '\0';
			}

			/* Configura la OLED */
			if (usart2DataReceived == 'c'){

				uint8_t array[26] = 	{0xAE, 0x00, 0x10,0x40, 0xB0, 0x81, 0xCF, 0xA1,
										 0xA6, 0xA8, 0x3F, 0xC8, 0xD3, 0x00, 0xD5, 0x80,
										 0xD9, 0xF1, 0xDA, 0x12, 0xDB, 0x20, 0x8D, 0x14,
										 0xAF, 0xAF};
				oled_sendCommand(&i2c_handler, array, 26);
				usart_writeMsg(&commSerial, "\r\n");
				usart_writeMsg(&commSerial, "Comando finalizado -> Debe leer 0\r\n");

				usart2DataReceived = '\0';
			}

			/* Apagar la OLED */
			if (usart2DataReceived == 'y'){

				usart_writeMsg(&commSerial, "\r\n");
				usart_writeMsg(&commSerial, "Pintando negro\r\n");

				usart2DataReceived = '\0';

				uint8_t array[128] = {0};
				array[127] = 0b11111111;

				oled_Config(&i2c_handler);

				oled_sendData(&i2c_handler, array, 128);

			}

			/* Apagar la OLED */
			if (usart2DataReceived == 'x'){

				usart2DataReceived = '\0';
			}

			if (usart2DataReceived == 'd'){
				usart_writeMsg(&commSerial, "\r\n");
				usart_writeMsg(&commSerial, "limpiando pantalla \r\n");

				usart2DataReceived = '\0';

				oled_Config(&i2c_handler);

				oled_clearDisplay(&i2c_handler);
			}




		}

	}

	return 0;

}

/*	Configuramos el pin*/

void init_system(void) {

	config_SysTick_ms(0);
	/*	Configuramos los pines*/

	/* userLed */
	userLed.pGPIOx = GPIOA;
	userLed.pinConfig.GPIO_PinNumber = PIN_5;
	userLed.pinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType = GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;

	/* Cargamos la configuracion de los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);

	/*configuramos los pines, y cargamos las configuraciones asi como aprendimos en la tarea #1, nada nuevo. Aqui
	 * los "leds" son las divisiones que tiene el 7segmentos (a,b,c,d....), entonces los pines van a estas divisiones
	 * y encienden estos "leds" enumerados alfabeticamente. El 7segmentos tambien puede verse como un pin muy grande con
	 * varias conexiones.
	 */

	/*	botonDerecho	*/
	botonDerecho.pGPIOx = GPIOC;
	botonDerecho.pinConfig.GPIO_PinNumber = PIN_8;
	botonDerecho.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonDerecho);

	/*	botonCentro	*/
	botonCentro.pGPIOx = GPIOC;
	botonCentro.pinConfig.GPIO_PinNumber = PIN_6;
	botonCentro.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonCentro);

	/*	botonIzquierdo*/
	botonIzquierdo.pGPIOx = GPIOC;
	botonIzquierdo.pinConfig.GPIO_PinNumber = PIN_5;
	botonIzquierdo.pinConfig.GPIO_PinMode = GPIO_MODE_IN;

	gpio_Config(&botonIzquierdo);

	/*Configuracion de los botones/EXTI */

	exti_botonDerecho.pGPIOHandler = &botonDerecho;
	exti_botonDerecho.edgeType = EXTERNAL_INTERRUPT_FALLING_EDGE;

	exti_Config(&exti_botonDerecho);

	exti_botonCentro.pGPIOHandler = &botonCentro;
	exti_botonCentro.edgeType = EXTERNAL_INTERRUPT_FALLING_EDGE;

	exti_Config(&exti_botonCentro);

	exti_botonIzquierdo.pGPIOHandler = &botonIzquierdo;
	exti_botonIzquierdo.edgeType = EXTERNAL_INTERRUPT_FALLING_EDGE;

	exti_Config(&exti_botonIzquierdo);

	//Timer del Blinky
	blinkyTimer.pTIMx = TIM5;
	blinkyTimer.TIMx_Config.TIMx_Prescaler = 16000; //	Genera incrementos de 1ms
	blinkyTimer.TIMx_Config.TIMx_Period = 250; //	el prescaler lo ajusta 1ms, entonces lo quiero a 250ms, y es la multiplicacion de uno con el otro.
	blinkyTimer.TIMx_Config.TIMx_mode = TIMER_UP_COUNTER;  //
	blinkyTimer.TIMx_Config.TIMx_InterruptEnable = TIMER_INT_ENABLE;  //

	/*	Configuramos el Timer */
	timer_Config(&blinkyTimer);

	//	Encedemos el Timer.
	timer_SetState(&blinkyTimer, SET);

	pwm_buzzer.ptrTIMx = TIM2;
	pwm_buzzer.config.channel = PWM_CHANNEL_2;
	pwm_buzzer.config.periodo = 200;
	pwm_buzzer.config.prescaler = 3; // freq
	pwm_buzzer.config.duttyCicle = 1; /* Se define el ciclo de trabajo (dutty cycle) del PWM en 100 (50%) */

	/* Se carga el PWM con los parametros establecidos */
	pwm_Config(&pwm_buzzer);

	/* Buzzer */
	gpio_buzzer.pGPIOx = GPIOB;
	gpio_buzzer.pinConfig.GPIO_PinNumber = PIN_3;
	gpio_buzzer.pinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	gpio_buzzer.pinConfig.GPIO_PinOutputType = GPIO_OTYPE_PUSHPULL;
	gpio_buzzer.pinConfig.GPIO_PinOutputSpeed = GPIO_OSPEED_MEDIUM;
	gpio_buzzer.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	gpio_buzzer.pinConfig.GPIO_PinAltFunMode = AF1;

	gpio_Config(&gpio_buzzer);

	// 4. ===== USARTS =====
	/* Configurando el puerto serial USART2 */

	commSerial.ptrUSARTx					= USART2;
	commSerial.USART_Config.baudrate		= USART_BAUDRATE_115200;
	commSerial.USART_Config.datasize		= USART_DATASIZE_8BIT;
	commSerial.USART_Config.parity			= USART_PARITY_NONE;
	commSerial.USART_Config.stopbits		= USART_STOPBIT_1;
	commSerial.USART_Config.mode			= USART_MODE_RXTX;
	commSerial.USART_Config.enableIntRX		= USART_RX_INTERRUP_ENABLE;

	/* Cargamos la configuración de USART */
	usart_Config(&commSerial);

	/*
	 * Escribimos el caracter nulo para asegurarnos de empezar
	 * una transmisión "limpia"
	 */
	usart_WriteChar(&commSerial, '\0');


	// 6. ===== I2C =====
	/* Configuramos el I2C */
	i2c_handler.pI2Cx				= I2C1;
	i2c_handler.slaveAddress		= OLED_ADDRESS;
	i2c_handler.i2c_mode				= eI2C_MODE_FM;

	/* Cargamos la configuración del I2C */
	i2c_Config(&i2c_handler);


	// 7. ===== SYSTICK =====
	/* Configuramos el Systick */
	config_SysTick_ms(0);



}

void tone(PWM_Handler_t *ptrPwmHandler, uint16_t newFreq, uint16_t duration) {

	uint16_t newPeriod = 0;
	newPeriod = 5333333 / newFreq;

	pwm_Update_Frequency(ptrPwmHandler, newPeriod);
	pwm_Update_DuttyCycle(ptrPwmHandler, duration);
	pwm_Start_Signal(ptrPwmHandler);

}
void noTone(PWM_Handler_t *ptrPwmHandler) {
	pwm_Stop_Signal(ptrPwmHandler);


void config_I2C(void)
{
	pinSCL.pGPIOx 								= GPIOB;
	pinSCL.pinConfig.GPIO_PinNumber        		= PIN_6;
	pinSCL.pinConfig.GPIO_PinMode          		= GPIO_MODE_ALTFN;
	pinSCL.pinConfig.GPIO_PinAltFunMode	  		= AF4;
	pinSCL.pinConfig.GPIO_PinOutputType   		= GPIO_OTYPE_OPENDRAIN;
	pinSCL.pinConfig.GPIO_PinOutputSpeed   	  	= GPIO_OSPEED_FAST;
	pinSCL.pinConfig.GPIO_PinPuPdControl  		= GPIO_PUPDR_NOTHING;
	gpio_Config(&pinSCL);

	pinSDA.pGPIOx 								= GPIOB;
	pinSDA.pinConfig.GPIO_PinNumber        		= PIN_9;
	pinSDA.pinConfig.GPIO_PinMode          		= GPIO_MODE_ALTFN;
	pinSDA.pinConfig.GPIO_PinAltFunMode	  		= AF4;
	pinSDA.pinConfig.GPIO_PinOutputType    		= GPIO_OTYPE_OPENDRAIN;
	pinSDA.pinConfig.GPIO_PinOutputSpeed   	  	= GPIO_OSPEED_FAST;
	pinSDA.pinConfig.GPIO_PinPuPdControl   		= GPIO_PUPDR_NOTHING;
	gpio_Config(&pinSDA);


}


// 7. ===== SYSTICK =====
	/* Configuramos el Systick */
	config_SysTick_ms(0);



		// 8. ===== I2C =====
		/* Configuramos el I2C */
		i2c_handler.pI2Cx				= I2C1;
		i2c_handler.slaveAddress		= OLED_ADDRESS;
		i2c_handler.i2c_mode			= eI2C_MODE_FM;


		/* Cargamos la configuración del I2C */
		i2c_Config(&i2c_handler);






}
//Callbacks del EXTI.

void callback_ExtInt8(void) {

	flag_botonDerecho = gpio_ReadPin(&botonDerecho);

}

void callback_ExtInt6(void) {

	flag_botonCentro += 1;
}

void callback_ExtInt5(void) {

	flag_botonIzquierdo += 1;
}

//Callbacks de los timers

/* este el callback del Led de estado, usamos el TooglePin para que se enciende y se apague, es la unico para lo
 * que nos sirve esta interrupcion. A grandes rasgos sirve para saber que el sistema funciona.

 Ademas de eso, agregamos la bandera para que se de la conversion de adc y la inicializacion de la variable sendMsg*/
void Timer5_Callback(void) {
	gpio_TooglePin(&userLed);

}

/* Callback usart2 */
void usart2_RxCallback(void){
	usart2DataReceived = usart_getRxData();
}

/*
 *Esta funcion sirve para detectar problemas de parametros
 *incorrectos
 **/
void assert_failed(uint8_t *file, uint32_t line) {
	while (1) {
		// problems
	}
}

